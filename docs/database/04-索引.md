#  MySQL索引

索引可以帮助我们更快的查找和获取指定行的数据，是增强数据库性能的常用手段。但是如果数据库索引使用不合理反而会降低数据库性能，所以我们需要了解索引的相关原理和使用规范。

创建索引语句为：CREATE INDEX idx_name ON test1 (name);

删除索引语句为：DROP INDEX idx_name;

## 索引类型

按照存储结构分为：

- HASH索引

  几乎唯一对应，在“=”和“in”条件下高效，但是对于范围查询、排序及组合索引就不太适合了。索引本身哈希函数的计算和碰撞问题也是需要解决的。

- B+树索引

  最常用也是默认的索引

  ![B+树](images/B+树.jpeg)

- Rtree索引

  在MySQL很少使用，仅支持geometry数据类型，相对于BTREE，RTREE的优势在于范围查找。

- FullText全文索引

  目前只有MyISAM引擎支持，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。全文索引并不是和MyISAM一起诞生的，它的出现是为了解决`WHERE name LIKE “%word%"`这类针对文本的模糊查询效率较低的问题。
  
- 有序数组

  搜索算法里提到的有序数组，即可以按照二分法快速查找某个值，也支持范围查询，但是动态插入不方便，只适合静态不变的历史数据。


## 索引种类

- 聚集索引
  聚簇索引指叶子结点存储实际表数据，或者说磁盘上数据文件就是聚集索引的顺序存放的，如innodb的主键索引 `*.ibd`文件。走聚集索引的话不必再根据地址去磁盘查。

- 二级索引/次级索引：

  对于二级索引，叶子结点存着主键的id，需要再次回表到聚簇索引那里查询其他字段数据。**一张表只能有唯一的聚簇索引**，但是可以有多个次级索引。

---------

按照索引的特性又可以分为：

- 普通索引：加速查询

- 主键索引：列值唯一（不可以有null）+ 表中只有一个

- 唯一索引： 列值唯一（可以有多个null）

  **唯一索引和主键索引的区别**：主键索引也属于唯一索引，表中只有一个，不允许有null，Innodb引擎下主键索引是聚集索引；唯一索引可以存在多个，允许有null；

- 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并

  ![联合索引](images/联合索引.png)

- 覆盖索引

  如果查询的列通过索引可直接返回，就称该索引**为查询sql的覆盖索引**(Covering Index)，也就是平时所说的不需要**回表操作**。[覆盖索引讲解](https://www.cnblogs.com/happyflyingpig/p/7662881.html)

  执行计划的extra列的using index 表明查询走的索引覆盖

- 前缀索引

  简单来说就是对字符列的前几个字符建立索引如`ADD KEY(email(6))`，这样的好处是降低索引文件的大小；但是不能精确匹配，导致回表的次数增加，也不能用作覆盖索引了。

  一般没必要为了优化索引的大小建立前缀索引。如果字符长度过长，mysql会自动建立前缀索引，降低查询效率。
  
  如果字段前几个字符区分度不高，可以建立倒序存储，或增加hash存储字段。但是注意此时不支持范围扫描了就，可以用于身份证，有一定规则的学号等字段
  
  首先，你可以使用下面这个语句，算出这个列上有多少个不同的值：
  
  ```mysql
  mysql> select count(distinct email) as L from SUser;
  ```
  
  然后，依次选取不同长度的前缀来看这个值，比如我们要看一下4~7个字节的前缀索引，可以用这个语句：
  
  ```mysql
  mysql> select 
  
   count(distinct left(email,4)）as L4,
  
   count(distinct left(email,5)）as L5,
  
   count(distinct left(email,6)）as L6,
  
   count(distinct left(email,7)）as L7,
  
  from SUser;
  ```
  
  当然，使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例，比如5%。然后，在返回的L4~L7中，找出不小于 L * 95%的值，假设这里L6、L7都满足，你就可以选择前缀长度为6。

## 索引条件下推

索引条件下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，用于优化查询。它的核心思想是：**将WHERE条件中可以在索引中判断的部分"下推"到存储引擎层执行，从而减少不必要的数据读取和传输**

在不使用ICP的情况下，在使用二级索引进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。

在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。这样就减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。

如建立联合索引（name，age），查询`where  name like '陈%' and age=20`，没有开启ICP时会直接通过name进行查询，查询出来行记录较多。而开启ICP，在索引内部就判断了age是不是等于20，匹配到的次数就较少。存储引擎传递给mysql服务器的数据就少了许多

在EXPLAIN执行计划的 Extra 列中，如果看到**Using index condition**，表示使用了索引下推。[https://blog.csdn.net/sinat_29774479/article/details/103470244](https://blog.csdn.net/sinat_29774479/article/details/103470244)

## MRR
除了ICP，MySQL还有哪些索引优化技术？

MRR工作原理：
二级索引查询得到一批主键ID
不是立即回表，而是先将主键ID排序
按照主键顺序批量回表查询

优势：
减少磁盘随机I/O，转为顺序I/O
充分利用磁盘预读能力

## 索引合并

在 MySQL 5.0 之前，一个表最多只能使用一个索引。从MySQL 5.1 开始引入索引合并（index_merge）技术优化，对同一个表可以使用多个索引分别进行条件扫描，然后将各自的结果进行合并（intersect/union）。

```sql
SELECT * FROM tbl_name WHERE key1 = 10 OR key2 = 20;
SELECT * FROM tbl_name WHERE (key1 = 10 OR key2 = 20) AND non_key=30;
SELECT * FROM t1, t2 WHERE (t1.key1 IN (1,2) OR t1.key2 LIKE 'value%') AND t2.key1=t1.some_col;
```

下面看一个例子：

```sql
index_merge之using union:
 mysql> explain 
 select count(0)
 from lessons
 where stu_id=116401
 or sel_id=1113;

| id | select_type | table   | type        | possible_keys                                                                          | key                               | key_len | ref  | rows | Extra                                                       |
|  1 | SIMPLE      | lessons | index_merge | lessons_stu_id,idx_stuid_lessub,IDX_LES_TYPE_STU_ID,stu_id_pay_type,idx_lessons_sel_id | lessons_stu_id,idx_lessons_sel_id | 4,5     | NULL | 1467 | Using union(lessons_stu_id,idx_lessons_sel_id); Using where |
+----+-------------+---------+-------------+----------------------------------------------------------------------------------------+-----------------------------------+---------+------+------+-------------------------------------------------------------+
1 row in set (0.09 sec)
查询使用 or 连接多个条件，查询分别使用 stu_id 和 sel_id 列索引进行扫描，并将扫描结果进行取并集(union)

index_merge之using intersect:
mysql> explain 
select count(0)
from lessons
where stu_id=116401
and sel_id=1113;
+----+-------------+---------+-------------+----------------------------------------------------------------------------------------+-----------------------------------+---------+------+------+------------------------------------------------------------------------------+
| id | select_type | table   | type        | possible_keys                                                                          | key                               | key_len | ref  | rows | Extra                                                                        |
+----+-------------+---------+-------------+----------------------------------------------------------------------------------------+-----------------------------------+---------+------+------+------------------------------------------------------------------------------+
|  1 | SIMPLE      | lessons | index_merge | lessons_stu_id,idx_stuid_lessub,IDX_LES_TYPE_STU_ID,stu_id_pay_type,idx_lessons_sel_id | lessons_stu_id,idx_lessons_sel_id | 4,5     | NULL |    1 | Using intersect(lessons_stu_id,idx_lessons_sel_id); Using where; Using index |
+----+-------------+---------+-------------+----------------------------------------------------------------------------------------+-----------------------------------+---------+------+------+------------------------------------------------------------------------------+
1 row in set (0.07 sec)
查询使用 and 连接多个条件，查询分别使用 stu_id 和 sel_id 列索引进行扫描，并将扫描结果进行取交集(intersect)
```

但是注意，如果where条件中有 >, <, >=, <=等条件，那么优化器不会使用 index merge，而且还会忽略其他的索引。

## 索引长度

索引的长度不仅决定了索引占用的数据空间大小，也会影响查找数据的 IO 次数。在同等数据量下，索引长度过长会导致单个数据页存放的索引条目数减少，索引高度增加，磁盘 IO 查询次数增加，并且索引占用空间增大。所以应该在满足要求的前提下，尽量减少索引长度。

索引的长度限制及计算方式如下：

1. 索引最大长度为 767 字节，若索引长度超过 767 字节将无法创建（可考虑创建前缀索引）

2. 索引长度与字段定义长度基本相同，前缀索引长度与定义的前缀长度有关

3. 变长类型如 varchar，额外需要 2 个字节存放索引长度

4. 如果字段可以为空，额外需要 1 个字节存放为空标识

**索引长度 = 字段长度 + 是否为空(+1) + 是否变长(+2)**

如name 字段 varchar(10) 可以为空，字符集为 utf8mb4 ，则索引长度为： **10*4B+1B+2B=43B**

而 a2 字段 int 可以为空，索引长度为：**4B+1B=5B**

## 索引页能存储的条目数量

我们知道，MySQL数据库page 大小默认为 16k ，即一次 IO 预读 16k 的数据到数据库的 buffer pool 中。每个索引除了索引长度外，还会用4B存储页号，6B存储其他数据。

假设表平均行长度为300B，主键索引列 ID 为 int 类型，普通索引列 name 为 varchar(20) 类型非空 (utf8mb4)，普通索引列 info 为 varchar(150) 类型可以为空 (utf8mb4)

- 主键索引

  每个非叶子节点可存放 key 个数为 `M1=16KB/(4B+4B+6B)≈1170`
  每个叶子节点可存放 key 个数为 `M2=16KB/(300B+4B+6B) ≈52`
  则 3 层索引最终能存放最大条目数为：`L=1170*1170*52 ≈7118W`，4 层索引最终能存放最大条目数为：`L=1170*1170*1170*52 ≈832亿`

- 二级索引name 索引字段本身长度为`20*4B+2B`

  每个非叶子节点可存放 key 个数为 `M1=16KB/(20*4B+2B+4B+6B)≈178`
  每个叶子节点可存放 key 个数为 `M2=16KB/(4B+20*4B+2B+4B+6B) ≈170`
  则 3 层索引最终能存放最大条目数为：`L= 178*178*170 ≈538W`， 4 层索引最终能存放最大条目数为：`L= 178*178*178*170 ≈9.58亿` 

- 二级索引info （varchar(150)），可为空， 索引字段本身长度为`150*4B+2B+1B`

  每个非叶子节点可存放 key 个数为 `M1=16KB/(150*4B+2B+1B+4B+6B)≈26`
  每个叶子节点可存放 key 个数为 `M2=16KB/(150*4B+2B+1B+4B+6B+4B) ≈26`
  则 3 层索引最终能存放最大条目数为：`L= 26*26*26 ≈17576`
  4 层索引最终能存放最大条目数为：`L= 26*26*26*26 ≈456976`
  5 层索引最终能存放最大条目数为：`L= 26*26*26*26*26 ≈1188W`

可以发现当索引长度增加时，会导致每个 page 页存放的索引数减少，索引高度增加。

特别是 char/varchar 类型，索引长度会因为 utf8mb4 字符集原因导致索引长度急剧增长，因此需要严格控制字段和索引长度。

## 索引设计原则

- 索引并不是越多越好，因为他会占用大量的磁盘，还会降低数据表的 DML 速度，因为数据增删改都会额外维护索引信息

- 合理使用联合索引和覆盖索引可以大大提高查询速度

- 不要在经常更新，区分度不高，字段太长的字段上添加索引；要在经常查询、排序的列上建立索引。字段过长可以考虑建立前缀索引。

- 重复索引可以删除。不合理的索引也可能导致优化器错误判断，有时反而选择性能低的索引

  如索引 index(A) 和 index(A,B) 是重复的，重复的索引需要更多的存储空间和维护代价，可考虑删除 index(A)。



如何给字符串字段建立索引

## 索引失效的情况（有坑！！）

- 优化器认为全表扫描更高效时，会不走索引。

  如当时一个名片申请列表的表，time列建立索引，根据time条件范围查询最近几个月的数据，MySQL优化器反而不走索引，直接全表扫描。查询一年前的数据或者时间范围足够大时，才走time的索引。

- 在索引上做任何操作（计算、函数、显式或隐式类型转换）会导致索引失效

- `!= is null，is not null`根据列中null值的多少有不同的情况。如果索引列的null值占多数，is not null 和!=走索引 ,is null不走索引了；如果null值很少时，is null就走索引，is not null 和!=不走索引。

  > 原因：走不走索引，是看mysql怎么估算成本的，二级索引的成本主要是二级索引本身的读取成本，和回表的成本。如当null值很多时，is not null 和!= 需要回表的行数就比较少，所以走索引，但是is null需要回表查很多记录那还不如直接取主键索引扫描全表。
  >
  > null值是存在对应索引的B+树的最左边的。[https://www.cnblogs.com/niuben/p/11197945.html](https://www.cnblogs.com/niuben/p/11197945.html)

- like '%abc' '%abc%'一定不走索引吗？

  一般来说，模糊查询，前置百分号%abc不走索引；后置百分号abc%才会走索引。

  但是要注意一种情况，如果该查询SQL属于覆盖索引，也就是select的字段只包含索引字段的话，也是走索引的。

  [https://www.cnblogs.com/bigsaltfish/p/10067179.html](https://www.cnblogs.com/bigsaltfish/p/10067179.html)

  > 可以这样理解：模糊查询%abc时，B+树是从左到右来比较字段是否相等的，而%abc此时前面的内容是不确定的，所以就要扫描全部索引（且sleet * 后续要继续回查主表），那还不如直接扫描全表。但是如果select 里只查询索引字段或者主键的话，那扫描整个索引就行，不需要回查主表，所以结果就走了索引！

- **or 一定不走索引吗**？一次查询只能使用一个索引吗？

  某些条件时，如上面的索引合并，可以同时使用两个索引，然后对结果取交集。

