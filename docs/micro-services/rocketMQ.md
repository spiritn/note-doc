# 基础概念

## 发送消息

同步发送：只要不抛异常就是成功

异步发送：

单向发送：只发送请求不等待应答，不会进行重试。很快（将数据写入客户端的socket缓冲区即可，此过程耗时通常在微秒级），适合日志收集可靠性不高的场景。

producer是线程安全的，可以在多个线程里进行发送。消息发送成功或者失败要打印消息日志，务必要打印SendResult和key字段

## 消费消息

- 集群订阅

  同一个Group ID所标识的所有Consumer为一个集群，他们平均分摊消费消息。这些消费者实例的订阅关系必须完全一致：

  - 订阅的Topic必须一致
  - 订阅的Topic中的Tag必须一致（包括Tag的数量和Tag的顺序）

- 广播订阅

  同一个Group ID所标识的所有Consumer都会各自消费某条消息一次



**客户端消费原理**

rocketMQ是采用消息队列推送push至consumer的方式。收费版还提供了pull的方式，即由Consumer主动从消息队列RocketMQ版拉取消息，这样可以更加自由地控制消息拉取。

![rocketMQ-消费原理](images/rocketMQ-消费原理.png)

1. SDK客户端通过长轮询批量拉取的方式从消息队列RocketMQ版服务端获取消息，将拉取到的消息缓存到本地缓冲队列中。

2. SDK客户端将本地缓存的消息提交到消费线程中，使用业务消费逻辑进行处理。



## 消息的类型

### 1. 顺序消息

​	全局顺序：对于指定的一个Topic，所有消息按照严格的先入先出FIFO（First In First Out）的顺序进行发布和消费

​	分区顺序：对于指定的一个Topic，所有消息根据Sharding Key进行分区。同一个分区内的消息按照严格的FIFO顺序进行发布和消费。相比全局顺序消息，性能高很多。

**原理解析**：

在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到不同的queue(分区队列)；而消费消息的时候从多个queue上拉取消息，这种情况发送和消费是不能保证顺序。但是如果控制发送的顺序消息只依次发送到同一个queue中，消费的时候只从这个queue上依次拉取，则就保证了顺序。当发送和消费参与的queue只有一个，则是全局有序；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。

**使用场景**：

- 用户注册需要发送发验证码，以用户ID作为Sharding Key，那么同一个用户发送的消息都会按照发布的先后顺序来消费

- 电商的订单创建，以订单ID作为Sharding Key，那么同一个订单相关的创建订单消息、订单支付消息、订单退款消息、订单物流消息都会按照发布的先后顺序来消费。 阿里巴巴集团内部电商系统均使用分区顺序消息，既保证业务的顺序，同时又能保证业务的高性能

常见问题：

> - 建议同一个Group ID只对应一种类型的Topic，即不同时用于顺序消息和无序消息的收发。
>
> - 对于全局顺序消息，建议消息不要有阻塞。同时运行多个实例，是为了防止工作实例意外退出而导致业务中断。当工作实例退出时，其他实例可以立即接手工作，不会导致业务中断，**实际工作的只会有一个实例**。
>
> - 同一条消息是否可以既是顺序消息，又是定时消息和事务消息？
>
>   不可以。顺序消息、定时消息、事务消息是不同的消息类型，三者是互斥关系，不能叠加在一起使用。
>
> - 为什么全局顺序消息性能一般？
>
>   全局顺序消息是严格按照FIFO的消息阻塞原则，即上一条消息没有被成功消费，那么下一条消息会一直被存储到Topic队列中。如果想提高全局顺序消息的TPS，可以升级实例配置，同时消息客户端应用尽量减少处理本地业务逻辑的耗时。
>
> - 顺序消息支持哪种消息发送方式？
>
>   顺序消息只支持可靠同步发送方式，不支持异步发送方式，否则将无法严格保证顺序。
>
> - 顺序消息是否支持集群消费和广播消费？
>
>   顺序消息暂时仅支持集群消费模式，不支持广播消费模式。

### 2. 事务消息

![事务消息](images/事务消息.png)

交互流程如下：

![事务消息流程](images/事务消息流程.png)



事务消息发送步骤如下：

1. 发送方将半事务消息发送至消息队列RocketMQ版服务端。
2. 消息队列RocketMQ版服务端将消息持久化成功之后，向发送方返回Ack确认消息已经发送成功，此时消息为半事务消息。
3. 发送方开始执行本地事务逻辑。
4. 发送方根据本地事务执行结果向服务端提交二次确认（Commit或是Rollback），服务端收到Commit状态则将半事务消息标记为可投递，订阅方最终将收到该消息；服务端收到Rollback状态则删除半事务消息，订阅方将不会接受该消息。

事务消息回查步骤如下：

1. 在断网或者是应用重启的特殊情况下，上述步骤4提交的二次确认最终未到达服务端，经过固定时间后服务端将对该消息发起消息回查。
2. 发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。
3. 发送方根据检查得到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤4对半事务消息进行操作。

### 3. 延时消息和定时消息

服务端在指定时间进行投递消息

- 指定时间最长支持40天，超过40天消息发送将失败。

- `StartDeliverTime`是服务端开始向消费端投递的时间。如果消费者当前有消息堆积，那么定时和延时消息会排在堆积消息后面，将不能严格按照配置的时间进行投递。

- 由于客户端和服务端可能存在时间差，消息的实际投递时间与客户端设置的投递时间之间可能存在偏差。

- 设置定时和延时消息的投递时间后，依然受3天的消息保存时长限制。

  例如，设置定时消息5天后才能被消费，如果第5天后一直没被消费，那么这条消息将在第8天被删除。

使用场景：

zm用在未填写报告，设置24h后自己发给自己触发自动生成报告。

电商交易中超时未支付关闭订单的场景，如30分钟投递消息，消费者判断是否支付。

某一固定时间点向客户发送提醒消息。

## rocketMQ应用场景

- 削峰填谷

  诸如秒杀、抢红包、企业开门红等大型活动时皆会带来较高的流量脉冲，或因没做相应的保护而导致系统超负荷甚至崩溃，或因限制太过导致请求大量失败而影响用户体验，消息队列RocketMQ版可提供削峰填谷的服务来解决该问题。

- 异步解耦

  交易系统作为淘宝和天猫主站最核心的系统，每笔交易订单数据的产生会引起几百个下游业务系统的关注，包括物流、购物车、积分、流计算分析等等，整体业务系统庞大而且复杂，消息队列RocketMQ版可实现异步通信和应用解耦，确保主站业务的连续性。

- 顺序收发

  细数日常中需要保证顺序的应用场景非常多，例如证券交易过程时间优先原则，交易系统中的订单创建、支付、退款等流程，航班中的旅客登机消息处理等等。与先进先出FIFO（First In First Out）原理类似，消息队列RocketMQ版提供的顺序消息即保证消息FIFO。

- 分布式事务一致性

  交易系统、支付红包等场景需要确保数据的最终一致性，大量引入消息队列RocketMQ版的分布式事务，既可以实现系统之间的解耦，又可以保证最终的数据一致性。

- 大数据分析

  数据在“流动”中产生价值，传统数据分析大多是基于批量计算模型，而无法做到实时的数据分析，利用阿里云消息队列RocketMQ版与流式计算引擎相结合，可以很方便的实现业务数据的实时分析。

- 分布式缓存同步

  天猫双11大促，各个分会场琳琅满目的商品需要实时感知价格变化，大量并发访问数据库导致会场页面响应时间长，集中式缓存因带宽瓶颈，限制了商品变更的访问流量，通过消息队列RocketMQ版构建分布式缓存，实时通知商品数据的变化





# 高级特性

## 消息重试

**顺序消息**

对于顺序消息，当消费者消费消息失败后，RocketMQ会自动不断地进行消息重试（每次间隔时间为1秒），这时，应用会出现消息消费被阻塞的情况。因此，使用顺序消息时，务必保证应用能够及时监控并处理消费失败的情况，避免阻塞现象的发生。

**无序消息**

对于无序消息，可以返回Action.ReconsumeLater，达到消息重试。返回null或者抛出异常也可以，但是推荐代码中try-catch返回Action.ReconsumeLater

注意只针对集群消费的方式，广播方式不提供消息重试特性，消费失败后不再进行重试，继续消费新的消息。

消息重试默认16次，10s, 30s, 1m, 2m, 3m,....10m, 20m,30m,1h, 2h，总共4小时46分钟，如果消费16次仍是失败，消息就不再进行投递。 

Consumer启动的时候可以设置最大重试次数，注意消息最大重试次数的设置对相同Group ID下的所有Consumer实例有效，也就是说如果只对相同Group ID下两个Consumer实例中的其中一个设置了MaxReconsumeTimes，那么该配置对两个Consumer实例均生效！
配置采用覆盖的方式生效，即最后启动的Consumer实例会覆盖之前的启动实例的配置。

**重试原理**

RocketMQ会为每个消费组都设置一个Topic名称为“%RETRY%+consumerGroup”的重试队列（这里需要注意的是，这个Topic的重试队列是针对消费组，而不是针对每个Topic设置的），用于暂时保存因为各种异常而导致Consumer端无法消费的消息。考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ对于重试消息的处理是先保存至Topic名称为“SCHEDULE_TOPIC_XXXX”的延迟队列中，后台定时任务按照对应的时间进行Delay后重新保存至“%RETRY%+consumerGroup”的重试队列中。

## 消费过滤

tag过滤：topic相当于一级分类，tag相当于二级分类。结合使用使业务结构清晰。

SQL过滤：producer可以自定义属性，consumer通过设置SQL语法的过滤表达式来过滤消息。

## 批量消费

批量消费可以提高消息处理的效率，降低调用其他服务的频率（即可以集中一批消息查其他服务的批量接口）。具体可以配置最大消息数量和最大等待时长。



基本术语：

- 分区

  即Topic Partition，物理上的概念。每个Topic包含一个或多个分区。

- 消费位点

  每个Topic会有多个分区，每个分区会统计当前消息的总条数，这个称为最大位点MaxOffset；分区的起始位置对应的叫做起始位点MinOffset。消息队列的Pull Consumer会按顺序依次消费分区内的每条消息，记录已经消费了的消息条数，称为消费位点ConsumerOffset。剩余的未消费的条数（也称为消息堆积量）= 最大位点MaxOffset-消费位点ConsumerOffset。

- 重置消费位点

  以时间轴为坐标，在消息持久化存储的时间范围内（默认3天），重新设置Consumer对已订阅的Topic的消费进度，设置完成后Consumer将接收设定时间点之后由Producer发送到消息队列RocketMQ版服务端的消息。更多信息，请参见[重置消费位点](https://help.aliyun.com/document_detail/63390.htm#task-2047153)。

- 死信队列
  死信队列用于处理无法被正常消费的消息。当一条消息初次消费失败，消息队列RocketMQ版会自动进行[消息重试](https://help.aliyun.com/document_detail/43490.htm#concept-2047068)；达到最大重试次数后，若消费依然失败，则表明Consumer在正常情况下无法正确地消费该消息。此时，消息队列RocketMQ版不会立刻将消息丢弃，而是将这条消息发送到该Consumer对应的特殊队列中。

  消息队列RocketMQ版将这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），将存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。可以通过使用console控制台对死信队列中的消息进行重发来使得消费者实例再次进行消费。

- 消息路由

  消息路由常用于不同地域之间的消息同步，保证地域之间的数据一致性。消息队列RocketMQ版的全球消息路由功能依托阿里云优质基础设施实现的高速通道专线，可以高效地实现不同地域之间的消息同步复制。更多信息，请参见[全球消息路由](https://help.aliyun.com/document_detail/90483.htm#concept-2047155)。

# 最佳实践

## 消息幂等

qos:

rocketMQ保证消息至少被消费一次。业务端应该自己处理保证消息幂等性。

另外rockerMQ提供了Exactly-Once投递语义，利用数据库来保证消息有且仅被消费一次。

消息重复的场景如下：

- 发送时消息重复

  当一条消息已被成功发送到服务端并完成持久化，此时出现了网络闪断或者客户端宕机，导致服务端对客户端应答失败。 如果此时生产者意识到消息发送失败并尝试再次发送消息，消费者后续会收到两条内容相同并且Message ID也相同的消息。

- 投递时消息重复

  消息消费的场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断。为了保证消息至少被消费一次，消息队列RocketMQ版的服务端将在网络恢复后再次尝试投递之前已被处理过的消息，消费者后续会收到两条内容相同并且Message ID也相同的消息。

- 负载均衡时消息重复（包括但不限于网络抖动、Broker重启以及消费者应用重启）

  当消息队列RocketMQ版的Broker或客户端重启、扩容或缩容时，会触发Rebalance，此时消费者可能会收到重复消息。

因为不同的Message ID对应的消息内容可能相同，有可能出现冲突（重复）的情况，所以真正安全的幂等处理，不建议以Message ID作为处理依据。

最好的方式是以业务唯一标识作为幂等处理的关键依据，业务的唯一标识要设置到keys字段`message.setKeys(orderId);`，方便将来定位消息丢失问题。服务器会为每个消息创建索引（哈希索引），应用可以通过topic、key来查询这条消息内容，以及消息被谁消费。由于是哈希索引，请务必保证key尽可能唯一，这样可以避免潜在的哈希冲突。

## 消息堆积和消息延迟

在消息处理流程中，如通过消息消费速度跟不上生产速度，未处理的消息越来越多，就会造成**消息堆积**。消息堆积会造成**消费延迟**，这会对业务造成较大影响，所以应尽力避免。尤其是对实时性要求较高的场景，即使短暂的消息延迟也无法接受时更应该关注此问题。

消息堆积的主要瓶颈在于客户端的消费能力，即[消费耗时](https://help.aliyun.com/document_detail/193875.html?spm=a2c4g.11186623.6.778.71a651d1wQboRc#section-qqy-2gu-l2k)和[消费并发度](https://help.aliyun.com/document_detail/193875.html?spm=a2c4g.11186623.6.778.71a651d1wQboRc#section-86m-h0h-ng2)。想要避免和解决消息堆积问题，必须合理的控制消费耗时和消息并发度，其中消费耗时的优先级高于消费并发度，必须先保证消费耗时的合理性，再考虑消费并发度问题。

影响消费耗时的主要分为CPU计算和外部IO操作，其中CPU计算一般相对IO操作都可以忽略。IO操作主要有读写外部数据库，下游系统调用。

消费并发度由单节点的消费线程数（默认20~64个）和节点数量共同决定，一般情况下需要优先调整单节点的消费线程数，若单机硬件资源达到上限，则必须通过扩容节点来提高消费并发度。不能盲目直接调大线程数，设置过大的线程数反而会带来大量的线程切换的开销。实际应用中，建议逐步调大线程的单个节点的线程数，并关测节点的系统指标，得到单个节点最优的消费线程数和消息吞吐量，然后，根据上下游链路的流量峰值计算出需要设置的节点数，节点数=流量峰值/单线程消息吞吐量

# 架构设计

![rocketmq_技术架构](images/rocketmq_技术架构.png)

由四个部分组成，每个都可以横向扩展，不会造成单点故障。

- Name Server：是一个非常简单的Topic路由注册中心，支持Broker的动态注册与发现。Broker是向每一台NameServer注册自己的路由信息，所以每个Name Server都记录了完整的路由信息。通常也是集群部署，节点之间无任何信息同步
  - broke 管理：NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活
  - Routing 管理：每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息，然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费
- Broker：主要负责消息的存储、投递和查询以及服务高可用保证。一个Master Broker对应多个Slave Broker。Broker启动后需要将自己注册至Name Server的操作；随后每隔30s定期向Name Server上报Topic路由信息。
- 生产者：与Name Server集群中的其中一个节点（随机）建立长链接（Keep-alive），定期从Name Server读取Topic路由信息，并向提供Topic服务的Master Broker建立长链接，且定时向Master Broker发送心跳。
- 消费者：与Name Server集群中的其中一个节点（随机）建立长连接，定期从Name Server拉取Topic路由信息，并向提供Topic服务的Master Broker、Slave Broker建立长连接，且定时向Master Broker、Slave Broker发送心跳。Consumer既可以从Master Broker订阅消息，也可以从Slave Broker订阅消息，订阅规则由Broker配置决定。

结合部署架构图，描述集群工作流程：

- 启动NameServer，NameServer起来后监听9876端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。
- Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。
- 收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。
- Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。
- Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。

