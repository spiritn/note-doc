
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://spiritn.github.io/note-doc/micro-services/apollo/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.1">
    
    
      
        <title>Apollo - 我的技术文档</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.484c7ddc.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="我的技术文档" class="md-header__button md-logo" aria-label="我的技术文档" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            我的技术文档
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Apollo
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-hidden="true"  type="radio" name="__palette" id="__palette_0">
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
  
    
  
  首页

      </a>
    </li>
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../database/02-mysql%E6%9E%B6%E6%9E%84/" class="md-tabs__link">
          
  
  
  数据库

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../java/java8/" class="md-tabs__link">
          
  
  
  Java

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../java/spring/spring/01-Overview/" class="md-tabs__link">
          
  
  
  spring

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../java/spring/spring-boot/GettingStarted/" class="md-tabs__link">
          
  
  
  springboot

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


  

<nav class="md-nav md-nav--primary md-nav--lifted md-nav--integrated" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="我的技术文档" class="md-nav__button md-logo" aria-label="我的技术文档" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    我的技术文档
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    首页
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    数据库
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    数据库
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../database/02-mysql%E6%9E%B6%E6%9E%84/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    mySQL架构
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../database/00-%E5%9F%BA%E7%A1%80/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    基础
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../database/03-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    InnoDB存储引擎
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../database/04-%E7%B4%A2%E5%BC%95/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    索引
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../database/05-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    日志系统
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Java
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    Java
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../java/java8/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    JAVA8
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    spring
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    spring
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../java/spring/spring/01-Overview/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    概览
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../java/spring/spring/02-IocContainer/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    IOC容器
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../java/spring/spring/03-Ioc%E5%AE%B9%E5%99%A8/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    IOC容器2
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../java/spring/spring/04-Resource/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Resource
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../java/spring/spring/Validation-DataBinding-Type-Conversion/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Validation
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../java/spring/spring/spring-AOP/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    AOP
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../java/spring/spring/Null-safetyAndLogging/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Null-safe
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../java/spring/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    spring常见问题
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_5" >
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    springboot
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            
  
    springboot
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../java/spring/spring-boot/GettingStarted/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    简介
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../java/spring/spring-boot/UsingSpringBoot/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    如何使用
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../java/spring/spring-boot/spring-boot-features/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    功能特性
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../java/spring/spring-boot/spring-boot%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    核心概念
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<p>Apollo是目前比较流行的分布式配置中心解决方案，韵达，掌门，携程都在使用。其他的解决方案还有Springcloud config , nacos等。</p>
<p>Apollo相比于其他解决方案，特有的优点是支持灰度发布，权限控制完善(修改和发布权限分离)，适合公司项目和人数较多的情况。</p>
<h1 id="1">1. 部署使用</h1>
<p><strong>安装启动</strong></p>
<p>Apollo分为服务端和客户端。</p>
<p>服务端只需要依赖mysql，导入portalDB和ConfigDB两个数据库脚本。然后分别启动configService，adminService, Portal三个服务。<a href="https://www.apolloconfig.com/#/zh/deployment/quick-start?id=%e4%ba%8c%e3%80%81%e5%ae%89%e8%a3%85%e6%ad%a5%e9%aa%a4">安装指南</a></p>
<p>configView.memberOnly.env设置为pro，可以配置只有项目管理员和具有发布修改的人才能查看私有的namespace。对敏感配置可以考虑开启<a href="https://github.com/ctripcorp/apollo/wiki/Apollo使用指南#62-配置访问秘钥">访问秘钥</a>，从而只有经过身份验证的客户端才能访问敏感配置</p>
<blockquote>
<p>dev,test,uat,prod四套环境因为物理环境分隔，所以部署了四套。都还是注册到eureka上，每个服务配置文件apollo-env.properties<code>里配置也都是fat.meta=http://fat-apollo-config.com
uat.meta=http://uat.apollo-config.com</code>等，这个地址也就是config Service服务域名，也可以直接访问到eureka的。</p>
</blockquote>
<h1 id="2">2. 总体设计</h1>
<p>配置是独立应用程序的只读变量，伴随应用的整个生命周期，应该有多个加载方式，并需要进行权限和不同环境集群的管理</p>
<p>application ：应用</p>
<p>environment： 不同的环境env：如prod，uat，staging，dev</p>
<p>cluster：一般用在不同数据中心，一个environment可以包含多个cluster</p>
<p>namespace：是配置项的集合，也就是对应一个个的配置文件。 分为私有配置和公有配置，如db-conn，Redis-conn。默认的名字是application。</p>
<p><img alt="IMG_7B7955D2C1FF-1.jpeg" src="../images/apollo.jpeg" /></p>
<p>apollo的总体设计如下图：</p>
<p><img alt="架构图.png" src="../images/jiagou.png" /></p>
<ul>
<li>Config Service提供配置的读取、推送等功能，服务对象是Apollo客户端</li>
<li>Admin Service提供配置的修改、发布等功能，服务对象是Apollo Portal（管理界面）</li>
<li>Config Service和Admin Service都是多实例、无状态部署，所以需要将自己注册到Eureka中并保持心跳</li>
<li>在Eureka之上我们架了一层Meta Server用于封装Eureka的服务发现接口，Client通过域名访问Meta Server获取Config Service服务列表（IP+Port），而后直接通过IP+Port访问服务，同时在Client侧会做load balance、错误重试。Portal通过域名访问Meta Server获取Admin Service服务列表（IP+Port），而后直接通过IP+Port访问服务，同时在Portal侧会做load balance、错误重试。为了简化部署，我们实际上会把Config Service、Eureka和Meta Server三个逻辑角色部署在同一个JVM进程中</li>
</ul>
<h3 id="config-service">Config Service</h3>
<ul>
<li>提供配置获取接口</li>
<li>
<p>提供配置更新推送接口（基于Http long polling 长连接轮询）</p>
</li>
<li>
<ul>
<li>服务端使用<a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/request/async/DeferredResult.html">Spring DeferredResult</a>实现异步化，从而大大增加长连接数量</li>
</ul>
</li>
<li>
<p>目前使用的tomcat embed默认配置是最多10000个连接（可以调整），使用了4C8G的虚拟机实测可以支撑10000个连接，所以满足需求（一个应用实例只会发起一个长连接）。</p>
</li>
<li>
<p>接口服务对象为Apollo客户端</p>
</li>
</ul>
<h3 id="admin-service">Admin Service</h3>
<ul>
<li>提供配置管理接口</li>
<li>提供配置修改、发布等接口</li>
<li>接口服务对象为Portal</li>
</ul>
<h3 id="meta-server">Meta Server</h3>
<ul>
<li>Portal通过域名访问Meta Server获取Admin Service服务列表（IP+Port）</li>
<li>Client通过域名访问Meta Server获取Config Service服务列表（IP+Port）</li>
<li>Meta Server从Eureka获取Config Service和Admin Service的服务信息，相当于是一个Eureka Client</li>
<li><strong>增设一个Meta Server的角色主要是为了封装服务发现的细节，对Portal和Client而言，永远通过一个Http接口获取Admin Service和Config Service的服务信息，而不需要关心背后实际的服务注册和发现组件</strong></li>
<li>Meta Server只是一个逻辑角色，在部署时和Config Service是在一个JVM进程中的，所以IP、端口和Config Service一致</li>
</ul>
<h3 id="eureka">Eureka</h3>
<ul>
<li>基于<a href="https://github.com/Netflix/eureka">Eureka</a>和<a href="https://cloud.spring.io/spring-cloud-netflix/">Spring Cloud Netflix</a>提供服务注册和发现</li>
<li>Config Service和Admin Service会向Eureka注册服务，并保持心跳</li>
<li>为了简单起见，目前Eureka在部署时和Config Service是在一个JVM进程中的（通过Spring Cloud Netflix）</li>
</ul>
<h3 id="portal">Portal</h3>
<ul>
<li>提供Web界面供用户管理配置</li>
<li>通过Meta Server获取Admin Service服务列表（IP+Port），通过IP+Port访问服务</li>
<li>在Portal侧做load balance、错误重试</li>
</ul>
<h3 id="client">Client</h3>
<ul>
<li>Apollo提供的客户端程序，为应用提供配置获取、实时更新等功能</li>
<li>通过Meta Server获取Config Service服务列表（IP+Port），通过IP+Port访问服务</li>
<li>在Client侧做load balance、错误重试</li>
</ul>
<p>模块划分：</p>
<p><img alt="模块" src="../images/%E6%A8%A1%E5%9D%97.png" /></p>
<h2 id="_1">其他设计</h2>
<p><img alt="领取模型" src="../images/%E9%A2%86%E5%8F%96%E6%A8%A1%E5%9E%8B.jpg" /></p>
<p>Audit是操作记录的模型，可以进行操作的审计</p>
<p><img alt="权限模型" src="../images/%E6%9D%83%E9%99%90%E6%A8%A1%E5%9E%8B.jpg" /></p>
<h2 id="apollo">apollo的高可用设计</h2>
<p>分布式配置中心是微服务中非常重要的服务，必须要保证高可用性，Apollo是如何保证高可用的呢？</p>
<p>configService多实例无状态部署，某台下线没有影响，所有的configService都下线会造成客户端无法读取最新配置，不过可以去本地缓存获取配置。</p>
<p>aadminService多实例无状态部署，某台下线没有影响，所有都下线会造成portal无法更新配置。同理所有portal服务下线也会造成用户无法更新配置。</p>
<p>数据库宕机，用户无法修改配置，configService配置有缓存，客户端仍可以来查询配置。</p>
<h2 id="apollo_1">Apollo的监控</h2>
<p>Apollo内置支持cat，但是只有在classpath扫描到cat的依赖才会启用。</p>
<p>可以定制扩展接入时序数据库，如InfluxDB等。</p>
<p>可以自己定制开发，记录一些关键指标，如接入应用数量，配置项数量，变更和发布数量，推送拉取次数，ConfigService服务的接口性能，GC，CPU等</p>
<h1 id="3">3. 配置发布通知流程</h1>
<p><img alt="配置发布流程图.png" src="../images/%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B.png" /></p>
<blockquote>
<p>Admin Service 在配置发布后，需要通知所有的 Config Service 有配置发布，从而 Config Service 可以通知对应的客户端来拉取最新的配置。</p>
<p>从概念上来看，这是一个典型的<strong>消息使用场景</strong>，Admin Service 作为 <strong>producer</strong> 发出消息，各个Config Service 作为 <strong>consumer</strong> 消费消息。通过一个<strong>消息组件</strong>（Message Queue）就能很好的实现 Admin Service 和 Config Service 的解耦。</p>
<p>在实现上，考虑到 Apollo 的实际使用场景，以及为了<strong>尽可能减少外部依赖</strong>，我们没有采用外部的消息中间件，而是通过<strong>数据库实现了一个简单的消息队列</strong>。</p>
<p>实现方式如下：</p>
<ol>
<li>Admin Service 在配置发布后会往 ReleaseMessage 表插入一条消息记录，消息内容就是配置发布的 AppId+Cluster+Namespace ，参见 DatabaseMessageSender 。</li>
<li>Config Service 有一个线程会每秒扫描一次 ReleaseMessage 表，看看是否有新的消息记录，参见 ReleaseMessageScanner 。</li>
<li>Config Service 如果发现有新的消息记录，那么就会通知到所有的消息监听器（ReleaseMessageListener），如 NotificationControllerV2 ，消息监听器的注册过程参见 ConfigServiceAutoConfiguration 。</li>
<li>NotificationControllerV2 得到配置发布的 <strong>AppId+Cluster+Namespace</strong> 后，会通知对应的客户端。</li>
</ol>
</blockquote>
<h2 id="1-releasemessage">1. 配置发布，ReleaseMessage表插入一条记录</h2>
<ol>
<li>
<p>用户在页面修改配置后，会通过portal服务调用adminService服务的ItemController.create()接口，保存修改后最新的配置项到item表</p>
</li>
<li>
<p>然后点击发布，会调用portal里的<code>ReleaseController.createRelease()</code>方法，里面先调用adminService服务的ReleaseController，然后会发布event出去，方便做些hook如发邮件，发个MQ消息。</p>
</li>
<li>
<p>adminService服务的<code>ReleaseController.publish()</code>接口：</p>
</li>
<li>
<p>先去检查namespace对应的锁是否被锁住（数据库namespacelock表实现的)，把对应的items转成json，保存到Release和releaseHistory表，这其中涉及到父namespace和子namespace灰度发布稍微复杂点。</p>
</li>
<li>然后调用<code>DatabaseMessageSender.sendMessage()</code>发送配置变更消息，也就是在ReleaseMessage表添加一条记录，如下表。利用id字段可以唯一表示这个nameSpace是否发生变更，client可以在请求时使用这个id作为版本号来判断是否发生了配置变更。</li>
</ol>
<table>
<thead>
<tr>
<th>Id</th>
<th>Message</th>
<th>DataChange_LastTime</th>
</tr>
</thead>
<tbody>
<tr>
<td>29</td>
<td>1212+default+application</td>
<td>2020-10-02 06:00:38</td>
</tr>
</tbody>
</table>
<p>另外为了防止ReleaseMessage表无限增长，会插一条记录到阻塞队列BlockingQueue里，后台线程会去轮询取出判断清空表。</p>
<h2 id="2-releasemessagelistener">2. 定时扫描ReleaseMessage表，发布变更消息给listener</h2>
<p>ReleaseMessageScanner初始化了一个定时任务线程池，每隔1秒去获取最新的500条数据，然后循环发送ReleaseMessage给每个 ReleaseMessageListener处理。</p>
<pre><code class="language-java">@Bean
public ReleaseMessageScanner releaseMessageScanner() {
    ReleaseMessageScanner releaseMessageScanner = new ReleaseMessageScanner();
    //0. handle release message cache 缓存Map&lt;message, releaseMessage&gt;
                  releaseMessageScanner.addMessageListener(releaseMessageServiceWithCache);
    //1. handle gray release rule
    releaseMessageScanner.addMessageListener(grayReleaseRulesHolder);
    //2. handle server cache
    releaseMessageScanner.addMessageListener(configService);
    releaseMessageScanner.addMessageListener(configFileController);
    //3. notify clients
    releaseMessageScanner.addMessageListener(notificationControllerV2);
    releaseMessageScanner.addMessageListener(notificationController);
    return releaseMessageScanner;
}
</code></pre>
<h2 id="3response">3.服务端挂起请求，异步返回response</h2>
<p>客户端每60秒来调用NotificationControllerV2.pollNotification()接口，服务端利用DeferredResult把请求挂起60秒，不立即返回response而是保存到一个map里。在listener的handMessage中有另外的线程中会在接收到相应的变更消息后,调用对应的DeferredResult.setResult()，立即返回response。</p>
<h1 id="4-apollo-client">4. Apollo-client解析</h1>
<h2 id="apollo-client">Apollo-client启动流程</h2>
<p>spring.factories文件里指定了两个Spring的配置类：</p>
<pre><code class="language-java">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.ctrip.framework.apollo.spring.boot.ApolloAutoConfiguration
org.springframework.context.ApplicationContextInitializer=\
com.ctrip.framework.apollo.spring.boot.ApolloApplicationContextInitializer
org.springframework.boot.env.EnvironmentPostProcessor=\
com.ctrip.framework.apollo.spring.boot.ApolloApplicationContextInitializer
</code></pre>
<h3 id="1-environmentapollo">1. 在Environment阶段注入apollo重要属性</h3>
<p>​   ApolloApplicationContextInitializer implements EnvironmentPostProcessor接口，它的postProcessEnvironment()方法把apollo系统属性（如appId）从环境变量中加载到系统属性里。</p>
<p>​   还提供了一个功能，如果开启了apollo.bootstrap.eagerLoad.enabled，就去急切的初始化namespace（即下面提到的），在日志系统加载前先读取Apollo配置。</p>
<pre><code class="language-java">@Override
public void postProcessEnvironment(ConfigurableEnvironment configurableEnvironment, SpringApplication springApplication) {
    // 先把一些apollo必需的属性先加载进来,这个方法不管什么配置方式都会执行，此时容器还没启动
    // should always initialize system properties like app.id in the first place
    initializeSystemProperty(configurableEnvironment);

    // 如果开启了apollo.bootstrap.eagerLoad.enabled = true
    if (bootstrapEnabled &amp;&amp; eagerLoadEnabled) {
        // 先去执行initialize方法初始化apollo配置，（可实现在日志系统加载之前就注入属性值）
        initialize(configurableEnvironment);
    }
}

void initializeSystemProperty(ConfigurableEnvironment environment) {
    for (String propertyName : APOLLO_SYSTEM_PROPERTIES) {
        // 从环境变量environment中把值填充进SystemProperty，直接从environment获取不好吗
        String propertyValue = environment.getProperty(propertyName);
        System.setProperty(propertyName, propertyValue);
    }
}
</code></pre>
<h3 id="2-applicationcontextinitializerproperty-sources">2. 在容器ApplicationContextInitializer阶段注册property sources</h3>
<blockquote>
<p>ApplicationContextInitializer名为初始化ApplicationContext，在ConfigurableApplicationContext.refresh()之前执行，一般用于注册property sources或者激活profiles</p>
</blockquote>
<p>ApplicationContextInitializer.initialize()方法中，如果配置文件配置了apollo.bootstrap.enabled=true，会把配置文件<code>apollo.bootstrap.namespaces=application,mq</code>里指定的所有namespace—&gt;config—&gt;ConfigPropertySource添加到environment的PropertySources中（name为ApolloBootstrapPropertySources，顺序为第一个）。</p>
<p>如果没有通过配置文件的方式指定<code>apollo.bootstrap.namespaces=application,mq</code>，而是通过@EnableApolloConfig(value="application")，则下面的@EnableApolloConfig会进行处理。也就是支持两种方式配置namespaces</p>
<h3 id="3-beandefinitions">3. 注册各种BeanDefinitions</h3>
<p>ApolloAutoConfiguration负责自动配置，条件为apollo.bootstrap.enabled=true且@ConditionalOnMissingBean(PropertySourcesProcessor.class)</p>
<pre><code class="language-java">@Configuration
@ConditionalOnProperty(PropertySourcesConstants.APOLLO_BOOTSTRAP_ENABLED) // 开启apollo.bootstrap.enabled=true
@ConditionalOnMissingBean(PropertySourcesProcessor.class) // 只有没有配置PropertySourcesProcessor时，才会开启自动配置
public class ApolloAutoConfiguration {
  @Bean
  public ConfigPropertySourcesProcessor configPropertySourcesProcessor() {
    return new ConfigPropertySourcesProcessor();
  }
}
</code></pre>
<p>它会生成一个Bean即ConfigPropertySourcesProcessor ，它委托ConfigPropertySourcesProcessorHelper注册多个BeanDefinition，比下面提到的DefaultApolloConfigRegistrarHelper少注册了个PropertySourcesProcessor。因为ConfigPropertySourcesProcessor extends PropertySourcesProcessor，本身就已经是个PropertySourcesProcessor了。</p>
<pre><code class="language-java">public class ConfigPropertySourcesProcessor extends PropertySourcesProcessor
    implements BeanDefinitionRegistryPostProcessor {

  private ConfigPropertySourcesProcessorHelper helper = ServiceBootstrap.loadPrimary(ConfigPropertySourcesProcessorHelper.class);

  @Override
  public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
    helper.postProcessBeanDefinitionRegistry(registry);
  }
}
</code></pre>
<p><strong>注解配置</strong></p>
<p>如果使用了@EnableApolloConfig注解，上面的自动配置就会失效。它Import 实现了ImportBeanDefinitionRegistrar接口的ApolloConfigRegistrar，里面委托DefaultApolloConfigRegistrarHelper注册多个BeanDefinition，如下：</p>
<pre><code class="language-java">@Override
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
    AnnotationAttributes attributes = AnnotationAttributes
        .fromMap(importingClassMetadata.getAnnotationAttributes(EnableApolloConfig.class.getName()));
    // 解析EnableApolloConfig注解里配置的namespaces。生产中一般是在配置文件里指定要获取的namespaces
    String[] namespaces = attributes.getStringArray(&quot;value&quot;);
    int order = attributes.getNumber(&quot;order&quot;);
 PropertySourcesProcessor.addNamespaces(Lists.newArrayList(namespaces), order);

    // PropertySourcesPlaceholderConfigurer负责替换PlaceHolder为对应的属性值，要确保先执行
    Map&lt;String, Object&gt; propertySourcesPlaceholderPropertyValues = new HashMap&lt;&gt;();
    // to make sure the default PropertySourcesPlaceholderConfigurer's priority is higher than PropertyPlaceholderConfigurer
    propertySourcesPlaceholderPropertyValues.put(&quot;order&quot;, 0);
    BeanRegistrationUtil.registerBeanDefinitionIfNotExists(registry, PropertySourcesPlaceholderConfigurer.class.getName(),
        PropertySourcesPlaceholderConfigurer.class, propertySourcesPlaceholderPropertyValues);

    // 注册PropertySourcesProcessor，将@EnableApolloConfig注解里配置的namespaces集成到Spring的PropertySources里
    BeanRegistrationUtil.registerBeanDefinitionIfNotExists(registry, PropertySourcesProcessor.class.getName(), PropertySourcesProcessor.class);

    // 注册ApolloAnnotationProcessor，它负责解析@ApolloConfigChangeListener和@ApolloConfig
    BeanRegistrationUtil.registerBeanDefinitionIfNotExists(registry, ApolloAnnotationProcessor.class.getName(), ApolloAnnotationProcessor.class);

    // 注册SpringValueProcessor 它负责加载所有的SpringValue，解析@Value
    BeanRegistrationUtil.registerBeanDefinitionIfNotExists(registry, SpringValueProcessor.class.getName(),
        SpringValueProcessor.class);

    // 注册SpringValueDefinitionProcessor，用于xml配置的bean
    BeanRegistrationUtil.registerBeanDefinitionIfNotExists(registry, SpringValueDefinitionProcessor.class.getName(), SpringValueDefinitionProcessor.class);

    // 注册ApolloJsonValueProcessor，解析@ApolloJsonValue
    BeanRegistrationUtil.registerBeanDefinitionIfNotExists(registry, ApolloJsonValueProcessor.class.getName(), ApolloJsonValueProcessor.class);
}
</code></pre>
<blockquote>
<p>以上的流程说明了同时支持xml配置和java配置两种配置方式。</p>
<p>如果是xml配置，则ApolloApplicationContextInitializer和ApolloAutoConfiguration生效；</p>
<p>如果是java配置即使用@EnableApolloConfig，则ApolloAutoConfiguration不再发挥作用，当然如果同时在xml和java中都指定了namespace，也没问题。</p>
</blockquote>
<p><img alt="image.png" src="../images/%E9%80%9A%E7%9F%A5%E5%AE%A2%E6%88%B7%E7%AB%AF.png" /></p>
<h2 id="_2">获取最新配置</h2>
<p>客户端通过长轮询和定时拉取两种方式去服务端获取配置：</p>
<p><img alt="客户端获取配置流程" src="../images/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B.png" /></p>
<blockquote>
<p>为什么不在推送时就返回具体配置信息？.</p>
<p>这样可以保持实时和设计上的简单。如果在推送中直接返回配置信息，会造成幂等性问题，消息丢失的问题（目前是单http连接，暂不用考虑顺序，但给以后设计如webSocket埋坑）；计算也比较复杂，还可能和定时轮询产生冲突造成双写。</p>
</blockquote>
<p><strong>客户端和服务端保持长连接，实现配置更新的推送</strong></p>
<p>其中长连接实际上是通过Http Long Polling实现的，具体而言：</p>
<ul>
<li>RemoteConfigLongPollService发起一个Http请求到服务端，超时90秒</li>
<li>
<p>服务端不会立即返回结果，而是通过<a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/request/async/DeferredResult.html">Spring DeferredResult</a>把请求挂起60秒</p>
</li>
<li>
<p>如果在60秒内有客户端关心的配置变化，实现了ReleaseMessageListener接口的NotificationControllerV2会调用对应的DeferredResult的<a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/request/async/DeferredResult.html#setResult-T-">setResult</a>方法，返回response。客户端从返回的结果中获取到配置变化的namespace后，会立即通知对应的RemoteConfigRepository请求服务端获取该namespace的最新配置。</p>
</li>
<li>
<p>如果在60秒内没有客户端关心的配置变化，那么会返回Http状态码304给客户端</p>
</li>
<li>客户端在收到服务端请求后会立即重新发起连接，回到第一步</li>
</ul>
<pre><code class="language-java">// 开启长轮询线程任务
m_longPollingService.submit(new Runnable() {
    @Override
    public void run() {
        // 在上面延迟一定时候后，开启轮询
        doLongPollingRefresh(appId, cluster, dataCenter, secret);
    }
});

private void doLongPollingRefresh(String appId, String cluster, String dataCenter, String secret) {
    final Random random = new Random();
    ServiceDTO lastServiceDto = null;
    // 循环不停执行，发出长轮询请求
    while (!m_longPollingStopped.get() &amp;&amp; !Thread.currentThread().isInterrupted()) {
        if (!m_longPollRateLimiter.tryAcquire(5, TimeUnit.SECONDS)) {
            //wait at most 5 seconds
            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
            }
        }
        String url = null;
        try {
            // 如果lastServiceDto不为空，就用上次的config服务地址。否则随机选取一个，实现负载均衡
            if (lastServiceDto == null) {
                List&lt;ServiceDTO&gt; configServices = getConfigServices();
                // list中随机取一个 random.nextInt
                lastServiceDto = configServices.get(random.nextInt(configServices.size()));
            }

            url = assembleLongPollRefreshUrl(lastServiceDto.getHomepageUrl(), appId, cluster, dataCenter,
                                             m_notifications);
            logger.debug(&quot;Long polling from {}&quot;, url);

            HttpRequest request = new HttpRequest(url);
            // 设置客户端的过期时间 90秒。服务端会60内返回。这里也是服务端不能超过90秒的原因
            request.setReadTimeout(LONG_POLLING_READ_TIMEOUT);

            // 这里发出了请求，得到response
            final HttpResponse&lt;List&lt;ApolloConfigNotification&gt;&gt; response = m_httpUtil.doGet(request, m_responseType);
            logger.debug(&quot;Long polling response: {}, url: {}&quot;, response.getStatusCode(), url);
            if (response.getStatusCode() == 200 &amp;&amp; response.getBody() != null) {
                // 去通知变更
                notify(lastServiceDto, response.getBody());
            }

            //try to load balance 随机重置lastServiceDto，
            if (response.getStatusCode() == 304 &amp;&amp; random.nextBoolean()) {
                lastServiceDto = null;
            }
            m_longPollFailSchedulePolicyInSecond.success();
        } catch (Throwable ex) {
            try {
                TimeUnit.SECONDS.sleep(sleepTimeInSecond);
            } catch (InterruptedException ie) {
            }
        }
    }
}
</code></pre>
<p><strong>客户端定时拉取最新配置</strong></p>
<p>这是一个fallback机制，为了防止推送机制失效导致配置不更新</p>
<p>客户端定时拉取并上报本地版本，一般情况下，对于定时拉取的操作，服务端都会返回304 - Not Modified。定时频率默认为每5分钟拉取一次，也可以通过指定System Property: <code>apollo.refreshInterval</code>来覆盖，单位为分钟。</p>
<pre><code class="language-java">// 每5分钟执行，去拉取apollo最新配置
m_executorService.scheduleAtFixedRate(
    new Runnable() {
        @Override
        public void run() {
            trySync();
        }
    }, m_configUtil.getRefreshInterval(), m_configUtil.getRefreshInterval(),
    m_configUtil.getRefreshIntervalTimeUnit());
</code></pre>
<h2 id="_3">实时更新配置</h2>
<p>先来了解下面几个概念：</p>
<p>我们在使用apollo时，经常使用到下面方式获取config：</p>
<pre><code class="language-java">Config config = ConfigService.getAppConfig(); // 这个就是去获取默认的getConfig(&quot;application&quot;)
Config config = ConfigService.getConfig(namespace);

// 或者属性注入的方式获取
@ApolloConfig
private Config config;
</code></pre>
<p>ConfigService相当于工具类，主要提供了getConfig(String namespace)和getAppConfig()方法。</p>
<p>它委托ConfigManager的实现类DefaultConfigManager.Map<namespace, Config>保存了所有namespace及其对应的Config，可以根据namespace返回对应的Config实例。为空则会利用ConfigFactoryManager找到对应的ConfigFactory去创建namespace对应的Config。</p>
<pre><code class="language-java">public class DefaultConfigManager implements ConfigManager {
  private ConfigFactoryManager m_factoryManager;

  // 保存所有namespace及其对应的Config
  private Map&lt;String, Config&gt; m_configs = Maps.newConcurrentMap();
  private Map&lt;String, ConfigFile&gt; m_configFiles = Maps.newConcurrentMap();

  /**
    * ConfigService.getConfig()会委托这个类来寻找namespace对应的Config，
    */
    @Override
    public Config getConfig(String namespace) {
        Config config = m_configs.get(namespace);

        if (config == null) {
            synchronized (this) {
                // 双重检查锁
                config = m_configs.get(namespace);

                if (config == null) {
                    ConfigFactory factory = m_factoryManager.getFactory(namespace);

                    config = factory.create(namespace);
                    m_configs.put(namespace, config);
                }
            }
        }

        return config;
    }
}

</code></pre>
<blockquote>
<p>SPI机制 (Service Provider Interface)，便于第三方或插件进项扩展添加自己的实现，提高扩展性。</p>
<p>相关接口为ConfigFactory，ConfigFactoryManager，ConfigRegistry，通过ConfigService类提供外部接口，具体来说是为指定namespace创建Config。</p>
</blockquote>
<p>DefaultConfigFactory负责为指定namespace创建DefaultConfig，为其创建对应的configRepository，一般是upstream关联了RemoteConfigRepository的LocalFileConfigRepository。</p>
<pre><code class="language-java">public class DefaultConfigFactory implements ConfigFactory {
  /**
   * 给指定namespace创建Config
   */
  @Override
  public Config create(String namespace) {
    ConfigFileFormat format = determineFileFormat(namespace);
    if (ConfigFileFormat.isPropertiesCompatible(format)) {
      return new DefaultConfig(namespace, createPropertiesCompatibleFileConfigRepository(namespace, format));
    }
    // 创建一个关联了RemoteConfigRepository的LocalFileConfigRepository
    return new DefaultConfig(namespace, new LocalFileConfigRepository(namespace, createRemoteConfigRepository(namespace)));
  }
}
</code></pre>
<p>实体映射关系为：</p>
<p>每个配置文件 —&gt; namespace —&gt; config  —&gt; DefaultConfig —&gt; LocalFileConfigRepository —&gt; RemoteConfigRepository</p>
<p><strong>ConfigRepository</strong></p>
<p>是配置项来源的抽象，负责获取配置，并在配置更新时发出通知。</p>
<p><img alt="ConfigRepository" src="../images/ConfigRepository.png" /></p>
<p>创建config时会创建对应的RemoteConfigRepository，在为指定namespace创建RemoteConfigRepository时，会初始化以下动作：</p>
<pre><code class="language-java">public RemoteConfigRepository(String namespace) {
    // 初始化时先去拉取一次配置
    this.trySync();
    // 每隔5分钟去定时拉取
    this.schedulePeriodicRefresh();
    // 注册到RemoteConfigLongPollService进行长轮询
    this.scheduleLongPollingRefresh();
}
</code></pre>
<p>其中长轮询是委托给RemoteConfigLongPollService统一进行管理，长轮询接收到配置变更后（返回200表示有变化）去通知关心该namespace的RemoteConfigRepository.onLongPollNotified()。然后RemoteConfigRepository立即重新去trySync()拉取配置，在sync()获取到变化的配置后，会依次通知各个RepositoryChangeListener，listener目前只有LocalFileConfigRepository。</p>
<p>LocalFileConfigRepository在接收到RepositoryChange时，会替换掉缓存并持久到本地文件系统里，并也发出fireRepositoryChange，listener为下面提到的DefaultConfig。</p>
<p><strong>Config</strong></p>
<p>Config是配置文件的抽象，对应一个namespace，负责配置的读取查询和变更通知。configFile类似，只不过是文件级别的，用的不多不再赘述。</p>
<p><img alt="config" src="../images/config.png" /></p>
<p>Config接口的抽象类AbstractConfig暴露了许多获取属性的方法，并做了缓存，还统一收口管理了ConfigChangeListener接口的实现类，在变更时进行通知。</p>
<p>AbstractConfig目前只有一个子类DefaultConfig，主要负责两件事情：一是实现了RepositoryChangeListener接口，在onRepositoryChange时来更新属性；二是实际负责获取属性（按照优先级去不同地方）</p>
<p>总结来说主要流程如下图：</p>
<p><img alt="apollo-配置通知" src="../images/apollo-%E9%85%8D%E7%BD%AE%E9%80%9A%E7%9F%A5.png" /></p>
<p>其中DefaultConfig收到RepositoryChange消息，计算出来更新的配置，然后fireConfigChange发出ConfigChangeEvent事件，通知各个listener。这里的listener包含添加@ApolloConfigChangeListener注解的；用户自己实现ConfigChangeListener接口的；还有负责处理@Value属性的AutoUpdateConfigChangeListener。</p>
<p><strong>apollo是如何自动更新Spring Placeholder的@value的属性的呢</strong>？</p>
<p>apollo在启动时，注册了一个SpringValueProcessor，它的父类abstract class ApolloProcessor实现了BeanPostProcessor，获取每个bean所有的Filed和Method属性。然后由子类SpringValueProcessor，遍历每个Field上是否有Value注解，获取placeholder里面的key，每个key对应一个SpringValue对象，然后注册到springValueRegistry，也就是说springValueRegistry持有了所有的SpringValue。</p>
<p>然后AutoUpdateConfigChangeListener实现了ConfigChangeListener接口，并持有springValueRegistry，所以在接收到DefaultConfig发布的配置变更后，循环遍历key，找到key对应的SpringValue，然后利用反射更新其值。</p>
<pre><code class="language-java">public void update(Object newVal)  {
    if (isField()) {
      injectField(newVal);
    } else {
      injectMethod(newVal);
    }
  }

  private void injectField(Object newVal) throws IllegalAccessException {
    Object bean = beanRef.get();
    if (bean == null) {
      return;
    }
    // 通过反射的方式直接更新值。Accessible先设为true，再改回去
    boolean accessible = field.isAccessible();
    field.setAccessible(true);
    field.set(bean, newVal);
    field.setAccessible(accessible);
  }

  private void injectMethod(Object newVal)
      throws InvocationTargetException, IllegalAccessException {
    Object bean = beanRef.get();
    if (bean == null) {
      return;
    }
    methodParameter.getMethod().invoke(bean, newVal);
  }
</code></pre>
<blockquote>
<p>但是这种方式有一个问题啊，apollo在初始化时是把配置属性集成到Spring的PropertySource 体系中的，但是上面的方式它是直接更新bean的属性值，并没有去更新PropertySource 体系中的值，也就是这时通过applicationContext.getEnvironment().getProperty(key)拿到的还是旧值（已验证确认）</p>
<p>不过springcloud提供了ContextRefresher.refresh()方法，里面<code>this.context.publishEvent(new EnvironmentChangeEvent(this.context, keys));</code>，spring会去重新加载配置</p>
</blockquote>
<p><strong>Apollo config如何集成到Spring PropertySource 体系中</strong>？</p>
<p>ConfigPropertySource继承了EnumerablePropertySource接口，是连接config和PropertySource接口的桥梁（PropertySource接口就是要求实现其getProperty()获取属性方法即可）。</p>
<p>一个ConfigPropertySource对应一个config，ConfigPropertySourceFactory注册了所有的ConfigPropertySource。在系统初始化时，ApolloApplicationContextInitializer和PropertySourcesProcessor会根据ConfigPropertySourceFactory拿到所有的ConfigPropertySource，然后注册到Spring的PropertySource 里<code>environment.getPropertySources().addFirst(composite)</code>。</p>
<h1 id="apollo_2">从apollo源码可以学习借鉴什么？</h1>
<p>集成Spring boot，如何读取配置文件，和@EnableApollo，如何动态注册Bean，如何使用BeanPostProcessor，如何动态修改Bean的属性值。</p>
<h2 id="spring">Spring相关</h2>
<ul>
<li>如何利用注解赋予当前字段值</li>
</ul>
<p>```java
  @Override
  protected void processField(Object bean, String beanName, Field field) {
      ApolloConfig annotation = AnnotationUtils.getAnnotation(field, ApolloConfig.class);
      Preconditions.checkArgument(Config.class.isAssignableFrom(field.getType()),
                                  "Invalid type: %s for field: %s, should be Config", field.getType(), field);</p>
<pre><code>  // 将自定义注解中的值解析，注入对应字段
  String namespace = annotation.value();
  Config config = ConfigService.getConfig(namespace);

  // 通过反射工具将值赋予字段
  ReflectionUtils.makeAccessible(field);
  ReflectionUtils.setField(field, bean, config);
</code></pre>
<p>}
  ```</p>
<ul>
<li>在方法上添加的注解，监听到变更后执行本方法。类似@EventListener</li>
</ul>
<p>```java
  // 示例
  @ApolloConfigChangeListener
  private void onChange1(ConfigChangeEvent changeEvent) {
      this.changeEvent1 = changeEvent;
  }</p>
<p>@Override
  protected void processMethod(final Object bean, String beanName, final Method method) {
      ConfigChangeListener configChangeListener = new ConfigChangeListener() {
        @Override
        public void onChange(ConfigChangeEvent changeEvent) {
          // 也就是说onChange时会调用method
          ReflectionUtils.invokeMethod(method, bean, changeEvent);
        }
      }; 
  }
  ```</p>
<h2 id="_4">设计模式</h2>
<ul>
<li>观察者模式</li>
</ul>
<p>代码中使用到了大量的观察者模式，用以代码解耦。ReleaseMessageScanner扫描到releaseMessage变更后，发出event。DefaultConfig在判断configChange后，发出event，等等。</p>
<ul>
<li>
<p>模板设计模式
    如config接口，在抽象类AbstractConfig定义一些通用的方法，中间某些关键的具体逻辑交给具体子类DefaultConfig来实现</p>
</li>
<li>
<p>工厂模式</p>
<p><img alt="DefaultConfigFactoryManager" src="../images/DefaultConfigFactoryManager.png" /></p>
</li>
</ul>
<h2 id="_5">编码技巧</h2>
<ul>
<li>使用java底层的http发出HTTP请求</li>
<li>Spring的DeferredResult,实现将请求挂起，异步返回response。也是长轮询如何实现的例子！</li>
</ul>
<p>部门OSS ak之前一直是明文配置在apollo上，管理不规范，一些开发甚至测试可能不小心造成泄漏。所以需要将其加密管理起来，利用jasypt，将密文ENC(密文)写在apollo里，将秘钥jasypt.encryptor.password在程序初始化时添加到environment的PropertySource中，第一位。这样程序就可以直接获取到明文了。</p>
<h1 id="_6">参考资料</h1>
<p><a href="https://www.iocoder.cn/categories/Apollo/">Apollo源码解析-芋道源码</a></p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../..", "features": ["navigation.tabs", "navigation.sections", "navigation.expand", "navigation.top", "navigation.instant", "navigation.tracking", "toc.follow", "toc.integrate", "search.highlight", "search.suggest", "content.code.copy"], "search": "../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>