
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://spiritn.github.io/note-doc/micro-services/apollo/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.1">
    
    
      
        <title>Apollo - 我的技术文档</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.484c7ddc.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="blue" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#config-service" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="我的技术文档" class="md-header__button md-logo" aria-label="我的技术文档" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            我的技术文档
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Apollo
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="blue" data-md-color-accent="indigo"  aria-hidden="true"  type="radio" name="__palette" id="__palette_0">
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



  

<nav class="md-nav md-nav--primary md-nav--integrated" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="我的技术文档" class="md-nav__button md-logo" aria-label="我的技术文档" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    我的技术文档
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_1" >
        
          
          <label class="md-nav__link" for="__nav_1" id="__nav_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    数据库
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1">
            <span class="md-nav__icon md-icon"></span>
            
  
    数据库
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../database/02-mysql%E6%9E%B6%E6%9E%84/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    mySQL架构
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../database/00-%E5%9F%BA%E7%A1%80/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    基础
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../database/03-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    InnoDB存储引擎
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../database/04-%E7%B4%A2%E5%BC%95/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    索引
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../database/05-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    日志系统
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Java
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Java
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../java/java8/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    JAVA8
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../java/spring/spring/IocContainer/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    spring
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<p>Apollo是目前比较流行的分布式配置中心解决方案，韵达，掌门，携程都在使用。其他的解决方案还有Springcloud config , nacos等。</p>
<p>Apollo相比于其他解决方案，特有的优点是支持灰度发布，权限控制完善(修改和发布权限分离)，适合公司项目和人数较多的情况。</p>
<h1 id="1">1. 部署使用<a class="headerlink" href="#1" title="Permanent link">&para;</a></h1>
<p><strong>安装启动</strong></p>
<p>Apollo分为服务端和客户端。</p>
<p>服务端只需要依赖mysql，导入portalDB和ConfigDB两个数据库脚本。然后分别启动configService，adminService, Portal三个服务。<a href="https://www.apolloconfig.com/#/zh/deployment/quick-start?id=%e4%ba%8c%e3%80%81%e5%ae%89%e8%a3%85%e6%ad%a5%e9%aa%a4">安装指南</a></p>
<p>configView.memberOnly.env设置为pro，可以配置只有项目管理员和具有发布修改的人才能查看私有的namespace。对敏感配置可以考虑开启<a href="https://github.com/ctripcorp/apollo/wiki/Apollo使用指南#62-配置访问秘钥">访问秘钥</a>，从而只有经过身份验证的客户端才能访问敏感配置</p>
<blockquote>
<p>dev,test,uat,prod四套环境因为物理环境分隔，所以部署了四套。都还是注册到eureka上，每个服务配置文件apollo-env.properties<code>里配置也都是fat.meta=http://fat-apollo-config.com
uat.meta=http://uat.apollo-config.com</code>等，这个地址也就是config Service服务域名，也可以直接访问到eureka的。</p>
</blockquote>
<h1 id="2">2. 总体设计<a class="headerlink" href="#2" title="Permanent link">&para;</a></h1>
<p>配置是独立应用程序的只读变量，伴随应用的整个生命周期，应该有多个加载方式，并需要进行权限和不同环境集群的管理</p>
<p>application ：应用</p>
<p>environment： 不同的环境env：如prod，uat，staging，dev</p>
<p>cluster：一般用在不同数据中心，一个environment可以包含多个cluster</p>
<p>namespace：是配置项的集合，也就是对应一个个的配置文件。 分为私有配置和公有配置，如db-conn，Redis-conn。默认的名字是application。</p>
<p><img alt="IMG_7B7955D2C1FF-1.jpeg" src="../images/apollo.jpeg" /></p>
<p>apollo的总体设计如下图：</p>
<p><img alt="架构图.png" src="../images/jiagou.png" /></p>
<ul>
<li>Config Service提供配置的读取、推送等功能，服务对象是Apollo客户端</li>
<li>Admin Service提供配置的修改、发布等功能，服务对象是Apollo Portal（管理界面）</li>
<li>Config Service和Admin Service都是多实例、无状态部署，所以需要将自己注册到Eureka中并保持心跳</li>
<li>在Eureka之上我们架了一层Meta Server用于封装Eureka的服务发现接口，Client通过域名访问Meta Server获取Config Service服务列表（IP+Port），而后直接通过IP+Port访问服务，同时在Client侧会做load balance、错误重试。Portal通过域名访问Meta Server获取Admin Service服务列表（IP+Port），而后直接通过IP+Port访问服务，同时在Portal侧会做load balance、错误重试。为了简化部署，我们实际上会把Config Service、Eureka和Meta Server三个逻辑角色部署在同一个JVM进程中</li>
</ul>
<h3 id="config-service">Config Service<a class="headerlink" href="#config-service" title="Permanent link">&para;</a></h3>
<ul>
<li>提供配置获取接口</li>
<li>
<p>提供配置更新推送接口（基于Http long polling 长连接轮询）</p>
</li>
<li>
<ul>
<li>服务端使用<a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/request/async/DeferredResult.html">Spring DeferredResult</a>实现异步化，从而大大增加长连接数量</li>
</ul>
</li>
<li>
<p>目前使用的tomcat embed默认配置是最多10000个连接（可以调整），使用了4C8G的虚拟机实测可以支撑10000个连接，所以满足需求（一个应用实例只会发起一个长连接）。</p>
</li>
<li>
<p>接口服务对象为Apollo客户端</p>
</li>
</ul>
<h3 id="admin-service">Admin Service<a class="headerlink" href="#admin-service" title="Permanent link">&para;</a></h3>
<ul>
<li>提供配置管理接口</li>
<li>提供配置修改、发布等接口</li>
<li>接口服务对象为Portal</li>
</ul>
<h3 id="meta-server">Meta Server<a class="headerlink" href="#meta-server" title="Permanent link">&para;</a></h3>
<ul>
<li>Portal通过域名访问Meta Server获取Admin Service服务列表（IP+Port）</li>
<li>Client通过域名访问Meta Server获取Config Service服务列表（IP+Port）</li>
<li>Meta Server从Eureka获取Config Service和Admin Service的服务信息，相当于是一个Eureka Client</li>
<li><strong>增设一个Meta Server的角色主要是为了封装服务发现的细节，对Portal和Client而言，永远通过一个Http接口获取Admin Service和Config Service的服务信息，而不需要关心背后实际的服务注册和发现组件</strong></li>
<li>Meta Server只是一个逻辑角色，在部署时和Config Service是在一个JVM进程中的，所以IP、端口和Config Service一致</li>
</ul>
<h3 id="eureka">Eureka<a class="headerlink" href="#eureka" title="Permanent link">&para;</a></h3>
<ul>
<li>基于<a href="https://github.com/Netflix/eureka">Eureka</a>和<a href="https://cloud.spring.io/spring-cloud-netflix/">Spring Cloud Netflix</a>提供服务注册和发现</li>
<li>Config Service和Admin Service会向Eureka注册服务，并保持心跳</li>
<li>为了简单起见，目前Eureka在部署时和Config Service是在一个JVM进程中的（通过Spring Cloud Netflix）</li>
</ul>
<h3 id="portal">Portal<a class="headerlink" href="#portal" title="Permanent link">&para;</a></h3>
<ul>
<li>提供Web界面供用户管理配置</li>
<li>通过Meta Server获取Admin Service服务列表（IP+Port），通过IP+Port访问服务</li>
<li>在Portal侧做load balance、错误重试</li>
</ul>
<h3 id="client">Client<a class="headerlink" href="#client" title="Permanent link">&para;</a></h3>
<ul>
<li>Apollo提供的客户端程序，为应用提供配置获取、实时更新等功能</li>
<li>通过Meta Server获取Config Service服务列表（IP+Port），通过IP+Port访问服务</li>
<li>在Client侧做load balance、错误重试</li>
</ul>
<p>模块划分：</p>
<p><img alt="模块" src="../images/%E6%A8%A1%E5%9D%97.png" /></p>
<h2 id="_1">其他设计<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<p><img alt="领取模型" src="../images/%E9%A2%86%E5%8F%96%E6%A8%A1%E5%9E%8B.jpg" /></p>
<p>Audit是操作记录的模型，可以进行操作的审计</p>
<p><img alt="权限模型" src="../images/%E6%9D%83%E9%99%90%E6%A8%A1%E5%9E%8B.jpg" /></p>
<h2 id="apollo">apollo的高可用设计<a class="headerlink" href="#apollo" title="Permanent link">&para;</a></h2>
<p>分布式配置中心是微服务中非常重要的服务，必须要保证高可用性，Apollo是如何保证高可用的呢？</p>
<p>configService多实例无状态部署，某台下线没有影响，所有的configService都下线会造成客户端无法读取最新配置，不过可以去本地缓存获取配置。</p>
<p>aadminService多实例无状态部署，某台下线没有影响，所有都下线会造成portal无法更新配置。同理所有portal服务下线也会造成用户无法更新配置。</p>
<p>数据库宕机，用户无法修改配置，configService配置有缓存，客户端仍可以来查询配置。</p>
<h2 id="apollo_1">Apollo的监控<a class="headerlink" href="#apollo_1" title="Permanent link">&para;</a></h2>
<p>Apollo内置支持cat，但是只有在classpath扫描到cat的依赖才会启用。</p>
<p>可以定制扩展接入时序数据库，如InfluxDB等。</p>
<p>可以自己定制开发，记录一些关键指标，如接入应用数量，配置项数量，变更和发布数量，推送拉取次数，ConfigService服务的接口性能，GC，CPU等</p>
<h1 id="3">3. 配置发布通知流程<a class="headerlink" href="#3" title="Permanent link">&para;</a></h1>
<p><img alt="配置发布流程图.png" src="../images/%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B.png" /></p>
<blockquote>
<p>Admin Service 在配置发布后，需要通知所有的 Config Service 有配置发布，从而 Config Service 可以通知对应的客户端来拉取最新的配置。</p>
<p>从概念上来看，这是一个典型的<strong>消息使用场景</strong>，Admin Service 作为 <strong>producer</strong> 发出消息，各个Config Service 作为 <strong>consumer</strong> 消费消息。通过一个<strong>消息组件</strong>（Message Queue）就能很好的实现 Admin Service 和 Config Service 的解耦。</p>
<p>在实现上，考虑到 Apollo 的实际使用场景，以及为了<strong>尽可能减少外部依赖</strong>，我们没有采用外部的消息中间件，而是通过<strong>数据库实现了一个简单的消息队列</strong>。</p>
<p>实现方式如下：</p>
<ol>
<li>Admin Service 在配置发布后会往 ReleaseMessage 表插入一条消息记录，消息内容就是配置发布的 AppId+Cluster+Namespace ，参见 DatabaseMessageSender 。</li>
<li>Config Service 有一个线程会每秒扫描一次 ReleaseMessage 表，看看是否有新的消息记录，参见 ReleaseMessageScanner 。</li>
<li>Config Service 如果发现有新的消息记录，那么就会通知到所有的消息监听器（ReleaseMessageListener），如 NotificationControllerV2 ，消息监听器的注册过程参见 ConfigServiceAutoConfiguration 。</li>
<li>NotificationControllerV2 得到配置发布的 <strong>AppId+Cluster+Namespace</strong> 后，会通知对应的客户端。</li>
</ol>
</blockquote>
<h2 id="1-releasemessage">1. 配置发布，ReleaseMessage表插入一条记录<a class="headerlink" href="#1-releasemessage" title="Permanent link">&para;</a></h2>
<ol>
<li>
<p>用户在页面修改配置后，会通过portal服务调用adminService服务的ItemController.create()接口，保存修改后最新的配置项到item表</p>
</li>
<li>
<p>然后点击发布，会调用portal里的<code>ReleaseController.createRelease()</code>方法，里面先调用adminService服务的ReleaseController，然后会发布event出去，方便做些hook如发邮件，发个MQ消息。</p>
</li>
<li>
<p>adminService服务的<code>ReleaseController.publish()</code>接口：</p>
</li>
<li>
<p>先去检查namespace对应的锁是否被锁住（数据库namespacelock表实现的)，把对应的items转成json，保存到Release和releaseHistory表，这其中涉及到父namespace和子namespace灰度发布稍微复杂点。</p>
</li>
<li>然后调用<code>DatabaseMessageSender.sendMessage()</code>发送配置变更消息，也就是在ReleaseMessage表添加一条记录，如下表。利用id字段可以唯一表示这个nameSpace是否发生变更，client可以在请求时使用这个id作为版本号来判断是否发生了配置变更。</li>
</ol>
<table>
<thead>
<tr>
<th>Id</th>
<th>Message</th>
<th>DataChange_LastTime</th>
</tr>
</thead>
<tbody>
<tr>
<td>29</td>
<td>1212+default+application</td>
<td>2020-10-02 06:00:38</td>
</tr>
</tbody>
</table>
<p>另外为了防止ReleaseMessage表无限增长，会插一条记录到阻塞队列BlockingQueue里，后台线程会去轮询取出判断清空表。</p>
<h2 id="2-releasemessagelistener">2. 定时扫描ReleaseMessage表，发布变更消息给listener<a class="headerlink" href="#2-releasemessagelistener" title="Permanent link">&para;</a></h2>
<p>ReleaseMessageScanner初始化了一个定时任务线程池，每隔1秒去获取最新的500条数据，然后循环发送ReleaseMessage给每个 ReleaseMessageListener处理。</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Bean</span>
<span class="kd">public</span><span class="w"> </span><span class="n">ReleaseMessageScanner</span><span class="w"> </span><span class="nf">releaseMessageScanner</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ReleaseMessageScanner</span><span class="w"> </span><span class="n">releaseMessageScanner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ReleaseMessageScanner</span><span class="p">();</span>
<span class="w">    </span><span class="c1">//0. handle release message cache 缓存Map&lt;message, releaseMessage&gt;</span>
<span class="w">                  </span><span class="n">releaseMessageScanner</span><span class="p">.</span><span class="na">addMessageListener</span><span class="p">(</span><span class="n">releaseMessageServiceWithCache</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//1. handle gray release rule</span>
<span class="w">    </span><span class="n">releaseMessageScanner</span><span class="p">.</span><span class="na">addMessageListener</span><span class="p">(</span><span class="n">grayReleaseRulesHolder</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//2. handle server cache</span>
<span class="w">    </span><span class="n">releaseMessageScanner</span><span class="p">.</span><span class="na">addMessageListener</span><span class="p">(</span><span class="n">configService</span><span class="p">);</span>
<span class="w">    </span><span class="n">releaseMessageScanner</span><span class="p">.</span><span class="na">addMessageListener</span><span class="p">(</span><span class="n">configFileController</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//3. notify clients</span>
<span class="w">    </span><span class="n">releaseMessageScanner</span><span class="p">.</span><span class="na">addMessageListener</span><span class="p">(</span><span class="n">notificationControllerV2</span><span class="p">);</span>
<span class="w">    </span><span class="n">releaseMessageScanner</span><span class="p">.</span><span class="na">addMessageListener</span><span class="p">(</span><span class="n">notificationController</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">releaseMessageScanner</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="3response">3.服务端挂起请求，异步返回response<a class="headerlink" href="#3response" title="Permanent link">&para;</a></h2>
<p>客户端每60秒来调用NotificationControllerV2.pollNotification()接口，服务端利用DeferredResult把请求挂起60秒，不立即返回response而是保存到一个map里。在listener的handMessage中有另外的线程中会在接收到相应的变更消息后,调用对应的DeferredResult.setResult()，立即返回response。</p>
<h1 id="4-apollo-client">4. Apollo-client解析<a class="headerlink" href="#4-apollo-client" title="Permanent link">&para;</a></h1>
<h2 id="apollo-client">Apollo-client启动流程<a class="headerlink" href="#apollo-client" title="Permanent link">&para;</a></h2>
<p>spring.factories文件里指定了两个Spring的配置类：</p>
<div class="highlight"><pre><span></span><code><span class="n">org</span><span class="p">.</span><span class="na">springframework</span><span class="p">.</span><span class="na">boot</span><span class="p">.</span><span class="na">autoconfigure</span><span class="p">.</span><span class="na">EnableAutoConfiguration</span><span class="o">=</span><span class="err">\</span>
<span class="n">com</span><span class="p">.</span><span class="na">ctrip</span><span class="p">.</span><span class="na">framework</span><span class="p">.</span><span class="na">apollo</span><span class="p">.</span><span class="na">spring</span><span class="p">.</span><span class="na">boot</span><span class="p">.</span><span class="na">ApolloAutoConfiguration</span>
<span class="n">org</span><span class="p">.</span><span class="na">springframework</span><span class="p">.</span><span class="na">context</span><span class="p">.</span><span class="na">ApplicationContextInitializer</span><span class="o">=</span><span class="err">\</span>
<span class="n">com</span><span class="p">.</span><span class="na">ctrip</span><span class="p">.</span><span class="na">framework</span><span class="p">.</span><span class="na">apollo</span><span class="p">.</span><span class="na">spring</span><span class="p">.</span><span class="na">boot</span><span class="p">.</span><span class="na">ApolloApplicationContextInitializer</span>
<span class="n">org</span><span class="p">.</span><span class="na">springframework</span><span class="p">.</span><span class="na">boot</span><span class="p">.</span><span class="na">env</span><span class="p">.</span><span class="na">EnvironmentPostProcessor</span><span class="o">=</span><span class="err">\</span>
<span class="n">com</span><span class="p">.</span><span class="na">ctrip</span><span class="p">.</span><span class="na">framework</span><span class="p">.</span><span class="na">apollo</span><span class="p">.</span><span class="na">spring</span><span class="p">.</span><span class="na">boot</span><span class="p">.</span><span class="na">ApolloApplicationContextInitializer</span>
</code></pre></div>
<h3 id="1-environmentapollo">1. 在Environment阶段注入apollo重要属性<a class="headerlink" href="#1-environmentapollo" title="Permanent link">&para;</a></h3>
<p>​   ApolloApplicationContextInitializer implements EnvironmentPostProcessor接口，它的postProcessEnvironment()方法把apollo系统属性（如appId）从环境变量中加载到系统属性里。</p>
<p>​   还提供了一个功能，如果开启了apollo.bootstrap.eagerLoad.enabled，就去急切的初始化namespace（即下面提到的），在日志系统加载前先读取Apollo配置。</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Override</span>
<span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">postProcessEnvironment</span><span class="p">(</span><span class="n">ConfigurableEnvironment</span><span class="w"> </span><span class="n">configurableEnvironment</span><span class="p">,</span><span class="w"> </span><span class="n">SpringApplication</span><span class="w"> </span><span class="n">springApplication</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 先把一些apollo必需的属性先加载进来,这个方法不管什么配置方式都会执行，此时容器还没启动</span>
<span class="w">    </span><span class="c1">// should always initialize system properties like app.id in the first place</span>
<span class="w">    </span><span class="n">initializeSystemProperty</span><span class="p">(</span><span class="n">configurableEnvironment</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 如果开启了apollo.bootstrap.eagerLoad.enabled = true</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bootstrapEnabled</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">eagerLoadEnabled</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 先去执行initialize方法初始化apollo配置，（可实现在日志系统加载之前就注入属性值）</span>
<span class="w">        </span><span class="n">initialize</span><span class="p">(</span><span class="n">configurableEnvironment</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">initializeSystemProperty</span><span class="p">(</span><span class="n">ConfigurableEnvironment</span><span class="w"> </span><span class="n">environment</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">propertyName</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">APOLLO_SYSTEM_PROPERTIES</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 从环境变量environment中把值填充进SystemProperty，直接从environment获取不好吗</span>
<span class="w">        </span><span class="n">String</span><span class="w"> </span><span class="n">propertyValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">environment</span><span class="p">.</span><span class="na">getProperty</span><span class="p">(</span><span class="n">propertyName</span><span class="p">);</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">setProperty</span><span class="p">(</span><span class="n">propertyName</span><span class="p">,</span><span class="w"> </span><span class="n">propertyValue</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="2-applicationcontextinitializerproperty-sources">2. 在容器ApplicationContextInitializer阶段注册property sources<a class="headerlink" href="#2-applicationcontextinitializerproperty-sources" title="Permanent link">&para;</a></h3>
<blockquote>
<p>ApplicationContextInitializer名为初始化ApplicationContext，在ConfigurableApplicationContext.refresh()之前执行，一般用于注册property sources或者激活profiles</p>
</blockquote>
<p>ApplicationContextInitializer.initialize()方法中，如果配置文件配置了apollo.bootstrap.enabled=true，会把配置文件<code>apollo.bootstrap.namespaces=application,mq</code>里指定的所有namespace—&gt;config—&gt;ConfigPropertySource添加到environment的PropertySources中（name为ApolloBootstrapPropertySources，顺序为第一个）。</p>
<p>如果没有通过配置文件的方式指定<code>apollo.bootstrap.namespaces=application,mq</code>，而是通过@EnableApolloConfig(value="application")，则下面的@EnableApolloConfig会进行处理。也就是支持两种方式配置namespaces</p>
<h3 id="3-beandefinitions">3. 注册各种BeanDefinitions<a class="headerlink" href="#3-beandefinitions" title="Permanent link">&para;</a></h3>
<p>ApolloAutoConfiguration负责自动配置，条件为apollo.bootstrap.enabled=true且@ConditionalOnMissingBean(PropertySourcesProcessor.class)</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Configuration</span>
<span class="nd">@ConditionalOnProperty</span><span class="p">(</span><span class="n">PropertySourcesConstants</span><span class="p">.</span><span class="na">APOLLO_BOOTSTRAP_ENABLED</span><span class="p">)</span><span class="w"> </span><span class="c1">// 开启apollo.bootstrap.enabled=true</span>
<span class="nd">@ConditionalOnMissingBean</span><span class="p">(</span><span class="n">PropertySourcesProcessor</span><span class="p">.</span><span class="na">class</span><span class="p">)</span><span class="w"> </span><span class="c1">// 只有没有配置PropertySourcesProcessor时，才会开启自动配置</span>
<span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ApolloAutoConfiguration</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nd">@Bean</span>
<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="n">ConfigPropertySourcesProcessor</span><span class="w"> </span><span class="nf">configPropertySourcesProcessor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConfigPropertySourcesProcessor</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>它会生成一个Bean即ConfigPropertySourcesProcessor ，它委托ConfigPropertySourcesProcessorHelper注册多个BeanDefinition，比下面提到的DefaultApolloConfigRegistrarHelper少注册了个PropertySourcesProcessor。因为ConfigPropertySourcesProcessor extends PropertySourcesProcessor，本身就已经是个PropertySourcesProcessor了。</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ConfigPropertySourcesProcessor</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">PropertySourcesProcessor</span>
<span class="w">    </span><span class="kd">implements</span><span class="w"> </span><span class="n">BeanDefinitionRegistryPostProcessor</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="n">ConfigPropertySourcesProcessorHelper</span><span class="w"> </span><span class="n">helper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ServiceBootstrap</span><span class="p">.</span><span class="na">loadPrimary</span><span class="p">(</span><span class="n">ConfigPropertySourcesProcessorHelper</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>

<span class="w">  </span><span class="nd">@Override</span>
<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">postProcessBeanDefinitionRegistry</span><span class="p">(</span><span class="n">BeanDefinitionRegistry</span><span class="w"> </span><span class="n">registry</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">BeansException</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">helper</span><span class="p">.</span><span class="na">postProcessBeanDefinitionRegistry</span><span class="p">(</span><span class="n">registry</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>注解配置</strong></p>
<p>如果使用了@EnableApolloConfig注解，上面的自动配置就会失效。它Import 实现了ImportBeanDefinitionRegistrar接口的ApolloConfigRegistrar，里面委托DefaultApolloConfigRegistrarHelper注册多个BeanDefinition，如下：</p>
<div class="highlight"><pre><span></span><code><span class="nd">@Override</span>
<span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">registerBeanDefinitions</span><span class="p">(</span><span class="n">AnnotationMetadata</span><span class="w"> </span><span class="n">importingClassMetadata</span><span class="p">,</span><span class="w"> </span><span class="n">BeanDefinitionRegistry</span><span class="w"> </span><span class="n">registry</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">AnnotationAttributes</span><span class="w"> </span><span class="n">attributes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AnnotationAttributes</span>
<span class="w">        </span><span class="p">.</span><span class="na">fromMap</span><span class="p">(</span><span class="n">importingClassMetadata</span><span class="p">.</span><span class="na">getAnnotationAttributes</span><span class="p">(</span><span class="n">EnableApolloConfig</span><span class="p">.</span><span class="na">class</span><span class="p">.</span><span class="na">getName</span><span class="p">()));</span>
<span class="w">    </span><span class="c1">// 解析EnableApolloConfig注解里配置的namespaces。生产中一般是在配置文件里指定要获取的namespaces</span>
<span class="w">    </span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">namespaces</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attributes</span><span class="p">.</span><span class="na">getStringArray</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attributes</span><span class="p">.</span><span class="na">getNumber</span><span class="p">(</span><span class="s">&quot;order&quot;</span><span class="p">);</span>
<span class="w"> </span><span class="n">PropertySourcesProcessor</span><span class="p">.</span><span class="na">addNamespaces</span><span class="p">(</span><span class="n">Lists</span><span class="p">.</span><span class="na">newArrayList</span><span class="p">(</span><span class="n">namespaces</span><span class="p">),</span><span class="w"> </span><span class="n">order</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// PropertySourcesPlaceholderConfigurer负责替换PlaceHolder为对应的属性值，要确保先执行</span>
<span class="w">    </span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Object</span><span class="o">&gt;</span><span class="w"> </span><span class="n">propertySourcesPlaceholderPropertyValues</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// to make sure the default PropertySourcesPlaceholderConfigurer&#39;s priority is higher than PropertyPlaceholderConfigurer</span>
<span class="w">    </span><span class="n">propertySourcesPlaceholderPropertyValues</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="s">&quot;order&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">BeanRegistrationUtil</span><span class="p">.</span><span class="na">registerBeanDefinitionIfNotExists</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="n">PropertySourcesPlaceholderConfigurer</span><span class="p">.</span><span class="na">class</span><span class="p">.</span><span class="na">getName</span><span class="p">(),</span>
<span class="w">        </span><span class="n">PropertySourcesPlaceholderConfigurer</span><span class="p">.</span><span class="na">class</span><span class="p">,</span><span class="w"> </span><span class="n">propertySourcesPlaceholderPropertyValues</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 注册PropertySourcesProcessor，将@EnableApolloConfig注解里配置的namespaces集成到Spring的PropertySources里</span>
<span class="w">    </span><span class="n">BeanRegistrationUtil</span><span class="p">.</span><span class="na">registerBeanDefinitionIfNotExists</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="n">PropertySourcesProcessor</span><span class="p">.</span><span class="na">class</span><span class="p">.</span><span class="na">getName</span><span class="p">(),</span><span class="w"> </span><span class="n">PropertySourcesProcessor</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 注册ApolloAnnotationProcessor，它负责解析@ApolloConfigChangeListener和@ApolloConfig</span>
<span class="w">    </span><span class="n">BeanRegistrationUtil</span><span class="p">.</span><span class="na">registerBeanDefinitionIfNotExists</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="n">ApolloAnnotationProcessor</span><span class="p">.</span><span class="na">class</span><span class="p">.</span><span class="na">getName</span><span class="p">(),</span><span class="w"> </span><span class="n">ApolloAnnotationProcessor</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 注册SpringValueProcessor 它负责加载所有的SpringValue，解析@Value</span>
<span class="w">    </span><span class="n">BeanRegistrationUtil</span><span class="p">.</span><span class="na">registerBeanDefinitionIfNotExists</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="n">SpringValueProcessor</span><span class="p">.</span><span class="na">class</span><span class="p">.</span><span class="na">getName</span><span class="p">(),</span>
<span class="w">        </span><span class="n">SpringValueProcessor</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 注册SpringValueDefinitionProcessor，用于xml配置的bean</span>
<span class="w">    </span><span class="n">BeanRegistrationUtil</span><span class="p">.</span><span class="na">registerBeanDefinitionIfNotExists</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="n">SpringValueDefinitionProcessor</span><span class="p">.</span><span class="na">class</span><span class="p">.</span><span class="na">getName</span><span class="p">(),</span><span class="w"> </span><span class="n">SpringValueDefinitionProcessor</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 注册ApolloJsonValueProcessor，解析@ApolloJsonValue</span>
<span class="w">    </span><span class="n">BeanRegistrationUtil</span><span class="p">.</span><span class="na">registerBeanDefinitionIfNotExists</span><span class="p">(</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="n">ApolloJsonValueProcessor</span><span class="p">.</span><span class="na">class</span><span class="p">.</span><span class="na">getName</span><span class="p">(),</span><span class="w"> </span><span class="n">ApolloJsonValueProcessor</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<p>以上的流程说明了同时支持xml配置和java配置两种配置方式。</p>
<p>如果是xml配置，则ApolloApplicationContextInitializer和ApolloAutoConfiguration生效；</p>
<p>如果是java配置即使用@EnableApolloConfig，则ApolloAutoConfiguration不再发挥作用，当然如果同时在xml和java中都指定了namespace，也没问题。</p>
</blockquote>
<p><img alt="image.png" src="../images/%E9%80%9A%E7%9F%A5%E5%AE%A2%E6%88%B7%E7%AB%AF.png" /></p>
<h2 id="_2">获取最新配置<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<p>客户端通过长轮询和定时拉取两种方式去服务端获取配置：</p>
<p><img alt="客户端获取配置流程" src="../images/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B.png" /></p>
<blockquote>
<p>为什么不在推送时就返回具体配置信息？.</p>
<p>这样可以保持实时和设计上的简单。如果在推送中直接返回配置信息，会造成幂等性问题，消息丢失的问题（目前是单http连接，暂不用考虑顺序，但给以后设计如webSocket埋坑）；计算也比较复杂，还可能和定时轮询产生冲突造成双写。</p>
</blockquote>
<p><strong>客户端和服务端保持长连接，实现配置更新的推送</strong></p>
<p>其中长连接实际上是通过Http Long Polling实现的，具体而言：</p>
<ul>
<li>RemoteConfigLongPollService发起一个Http请求到服务端，超时90秒</li>
<li>
<p>服务端不会立即返回结果，而是通过<a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/request/async/DeferredResult.html">Spring DeferredResult</a>把请求挂起60秒</p>
</li>
<li>
<p>如果在60秒内有客户端关心的配置变化，实现了ReleaseMessageListener接口的NotificationControllerV2会调用对应的DeferredResult的<a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/request/async/DeferredResult.html#setResult-T-">setResult</a>方法，返回response。客户端从返回的结果中获取到配置变化的namespace后，会立即通知对应的RemoteConfigRepository请求服务端获取该namespace的最新配置。</p>
</li>
<li>
<p>如果在60秒内没有客户端关心的配置变化，那么会返回Http状态码304给客户端</p>
</li>
<li>客户端在收到服务端请求后会立即重新发起连接，回到第一步</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">// 开启长轮询线程任务</span>
<span class="n">m_longPollingService</span><span class="p">.</span><span class="na">submit</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Runnable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 在上面延迟一定时候后，开启轮询</span>
<span class="w">        </span><span class="n">doLongPollingRefresh</span><span class="p">(</span><span class="n">appId</span><span class="p">,</span><span class="w"> </span><span class="n">cluster</span><span class="p">,</span><span class="w"> </span><span class="n">dataCenter</span><span class="p">,</span><span class="w"> </span><span class="n">secret</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>

<span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">doLongPollingRefresh</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">appId</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">cluster</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">dataCenter</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">secret</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">Random</span><span class="w"> </span><span class="n">random</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Random</span><span class="p">();</span>
<span class="w">    </span><span class="n">ServiceDTO</span><span class="w"> </span><span class="n">lastServiceDto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// 循环不停执行，发出长轮询请求</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">m_longPollingStopped</span><span class="p">.</span><span class="na">get</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">isInterrupted</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">m_longPollRateLimiter</span><span class="p">.</span><span class="na">tryAcquire</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">SECONDS</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">//wait at most 5 seconds</span>
<span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">SECONDS</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">String</span><span class="w"> </span><span class="n">url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// 如果lastServiceDto不为空，就用上次的config服务地址。否则随机选取一个，实现负载均衡</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lastServiceDto</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">List</span><span class="o">&lt;</span><span class="n">ServiceDTO</span><span class="o">&gt;</span><span class="w"> </span><span class="n">configServices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getConfigServices</span><span class="p">();</span>
<span class="w">                </span><span class="c1">// list中随机取一个 random.nextInt</span>
<span class="w">                </span><span class="n">lastServiceDto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">configServices</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="na">nextInt</span><span class="p">(</span><span class="n">configServices</span><span class="p">.</span><span class="na">size</span><span class="p">()));</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="n">url</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assembleLongPollRefreshUrl</span><span class="p">(</span><span class="n">lastServiceDto</span><span class="p">.</span><span class="na">getHomepageUrl</span><span class="p">(),</span><span class="w"> </span><span class="n">appId</span><span class="p">,</span><span class="w"> </span><span class="n">cluster</span><span class="p">,</span><span class="w"> </span><span class="n">dataCenter</span><span class="p">,</span>
<span class="w">                                             </span><span class="n">m_notifications</span><span class="p">);</span>
<span class="w">            </span><span class="n">logger</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&quot;Long polling from {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">url</span><span class="p">);</span>

<span class="w">            </span><span class="n">HttpRequest</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HttpRequest</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
<span class="w">            </span><span class="c1">// 设置客户端的过期时间 90秒。服务端会60内返回。这里也是服务端不能超过90秒的原因</span>
<span class="w">            </span><span class="n">request</span><span class="p">.</span><span class="na">setReadTimeout</span><span class="p">(</span><span class="n">LONG_POLLING_READ_TIMEOUT</span><span class="p">);</span>

<span class="w">            </span><span class="c1">// 这里发出了请求，得到response</span>
<span class="w">            </span><span class="kd">final</span><span class="w"> </span><span class="n">HttpResponse</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">ApolloConfigNotification</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_httpUtil</span><span class="p">.</span><span class="na">doGet</span><span class="p">(</span><span class="n">request</span><span class="p">,</span><span class="w"> </span><span class="n">m_responseType</span><span class="p">);</span>
<span class="w">            </span><span class="n">logger</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&quot;Long polling response: {}, url: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">response</span><span class="p">.</span><span class="na">getStatusCode</span><span class="p">(),</span><span class="w"> </span><span class="n">url</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="na">getStatusCode</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">response</span><span class="p">.</span><span class="na">getBody</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// 去通知变更</span>
<span class="w">                </span><span class="n">notify</span><span class="p">(</span><span class="n">lastServiceDto</span><span class="p">,</span><span class="w"> </span><span class="n">response</span><span class="p">.</span><span class="na">getBody</span><span class="p">());</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="c1">//try to load balance 随机重置lastServiceDto，</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="na">getStatusCode</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">304</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">random</span><span class="p">.</span><span class="na">nextBoolean</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">lastServiceDto</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">m_longPollFailSchedulePolicyInSecond</span><span class="p">.</span><span class="na">success</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">Throwable</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">SECONDS</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">sleepTimeInSecond</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">ie</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>客户端定时拉取最新配置</strong></p>
<p>这是一个fallback机制，为了防止推送机制失效导致配置不更新</p>
<p>客户端定时拉取并上报本地版本，一般情况下，对于定时拉取的操作，服务端都会返回304 - Not Modified。定时频率默认为每5分钟拉取一次，也可以通过指定System Property: <code>apollo.refreshInterval</code>来覆盖，单位为分钟。</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 每5分钟执行，去拉取apollo最新配置</span>
<span class="n">m_executorService</span><span class="p">.</span><span class="na">scheduleAtFixedRate</span><span class="p">(</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="n">Runnable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nd">@Override</span>
<span class="w">        </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">trySync</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span><span class="n">m_configUtil</span><span class="p">.</span><span class="na">getRefreshInterval</span><span class="p">(),</span><span class="w"> </span><span class="n">m_configUtil</span><span class="p">.</span><span class="na">getRefreshInterval</span><span class="p">(),</span>
<span class="w">    </span><span class="n">m_configUtil</span><span class="p">.</span><span class="na">getRefreshIntervalTimeUnit</span><span class="p">());</span>
</code></pre></div>
<h2 id="_3">实时更新配置<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h2>
<p>先来了解下面几个概念：</p>
<p>我们在使用apollo时，经常使用到下面方式获取config：</p>
<div class="highlight"><pre><span></span><code><span class="n">Config</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ConfigService</span><span class="p">.</span><span class="na">getAppConfig</span><span class="p">();</span><span class="w"> </span><span class="c1">// 这个就是去获取默认的getConfig(&quot;application&quot;)</span>
<span class="n">Config</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ConfigService</span><span class="p">.</span><span class="na">getConfig</span><span class="p">(</span><span class="n">namespace</span><span class="p">);</span>

<span class="c1">// 或者属性注入的方式获取</span>
<span class="nd">@ApolloConfig</span>
<span class="kd">private</span><span class="w"> </span><span class="n">Config</span><span class="w"> </span><span class="n">config</span><span class="p">;</span>
</code></pre></div>
<p>ConfigService相当于工具类，主要提供了getConfig(String namespace)和getAppConfig()方法。</p>
<p>它委托ConfigManager的实现类DefaultConfigManager.Map<namespace, Config>保存了所有namespace及其对应的Config，可以根据namespace返回对应的Config实例。为空则会利用ConfigFactoryManager找到对应的ConfigFactory去创建namespace对应的Config。</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">DefaultConfigManager</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">ConfigManager</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="n">ConfigFactoryManager</span><span class="w"> </span><span class="n">m_factoryManager</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// 保存所有namespace及其对应的Config</span>
<span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">Config</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_configs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maps</span><span class="p">.</span><span class="na">newConcurrentMap</span><span class="p">();</span>
<span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">ConfigFile</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_configFiles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maps</span><span class="p">.</span><span class="na">newConcurrentMap</span><span class="p">();</span>

<span class="w">  </span><span class="cm">/**</span>
<span class="cm">    * ConfigService.getConfig()会委托这个类来寻找namespace对应的Config，</span>
<span class="cm">    */</span>
<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Config</span><span class="w"> </span><span class="nf">getConfig</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">namespace</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Config</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_configs</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">namespace</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">config</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">synchronized</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// 双重检查锁</span>
<span class="w">                </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_configs</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">namespace</span><span class="p">);</span>

<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">config</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">ConfigFactory</span><span class="w"> </span><span class="n">factory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m_factoryManager</span><span class="p">.</span><span class="na">getFactory</span><span class="p">(</span><span class="n">namespace</span><span class="p">);</span>

<span class="w">                    </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factory</span><span class="p">.</span><span class="na">create</span><span class="p">(</span><span class="n">namespace</span><span class="p">);</span>
<span class="w">                    </span><span class="n">m_configs</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span><span class="w"> </span><span class="n">config</span><span class="p">);</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">config</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<p>SPI机制 (Service Provider Interface)，便于第三方或插件进项扩展添加自己的实现，提高扩展性。</p>
<p>相关接口为ConfigFactory，ConfigFactoryManager，ConfigRegistry，通过ConfigService类提供外部接口，具体来说是为指定namespace创建Config。</p>
</blockquote>
<p>DefaultConfigFactory负责为指定namespace创建DefaultConfig，为其创建对应的configRepository，一般是upstream关联了RemoteConfigRepository的LocalFileConfigRepository。</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">DefaultConfigFactory</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">ConfigFactory</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cm">/**</span>
<span class="cm">   * 给指定namespace创建Config</span>
<span class="cm">   */</span>
<span class="w">  </span><span class="nd">@Override</span>
<span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="n">Config</span><span class="w"> </span><span class="nf">create</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">namespace</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ConfigFileFormat</span><span class="w"> </span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">determineFileFormat</span><span class="p">(</span><span class="n">namespace</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ConfigFileFormat</span><span class="p">.</span><span class="na">isPropertiesCompatible</span><span class="p">(</span><span class="n">format</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DefaultConfig</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span><span class="w"> </span><span class="n">createPropertiesCompatibleFileConfigRepository</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span><span class="w"> </span><span class="n">format</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// 创建一个关联了RemoteConfigRepository的LocalFileConfigRepository</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DefaultConfig</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LocalFileConfigRepository</span><span class="p">(</span><span class="n">namespace</span><span class="p">,</span><span class="w"> </span><span class="n">createRemoteConfigRepository</span><span class="p">(</span><span class="n">namespace</span><span class="p">)));</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>实体映射关系为：</p>
<p>每个配置文件 —&gt; namespace —&gt; config  —&gt; DefaultConfig —&gt; LocalFileConfigRepository —&gt; RemoteConfigRepository</p>
<p><strong>ConfigRepository</strong></p>
<p>是配置项来源的抽象，负责获取配置，并在配置更新时发出通知。</p>
<p><img alt="ConfigRepository" src="../images/ConfigRepository.png" /></p>
<p>创建config时会创建对应的RemoteConfigRepository，在为指定namespace创建RemoteConfigRepository时，会初始化以下动作：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="nf">RemoteConfigRepository</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">namespace</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 初始化时先去拉取一次配置</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">trySync</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// 每隔5分钟去定时拉取</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">schedulePeriodicRefresh</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// 注册到RemoteConfigLongPollService进行长轮询</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">scheduleLongPollingRefresh</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>其中长轮询是委托给RemoteConfigLongPollService统一进行管理，长轮询接收到配置变更后（返回200表示有变化）去通知关心该namespace的RemoteConfigRepository.onLongPollNotified()。然后RemoteConfigRepository立即重新去trySync()拉取配置，在sync()获取到变化的配置后，会依次通知各个RepositoryChangeListener，listener目前只有LocalFileConfigRepository。</p>
<p>LocalFileConfigRepository在接收到RepositoryChange时，会替换掉缓存并持久到本地文件系统里，并也发出fireRepositoryChange，listener为下面提到的DefaultConfig。</p>
<p><strong>Config</strong></p>
<p>Config是配置文件的抽象，对应一个namespace，负责配置的读取查询和变更通知。configFile类似，只不过是文件级别的，用的不多不再赘述。</p>
<p><img alt="config" src="../images/config.png" /></p>
<p>Config接口的抽象类AbstractConfig暴露了许多获取属性的方法，并做了缓存，还统一收口管理了ConfigChangeListener接口的实现类，在变更时进行通知。</p>
<p>AbstractConfig目前只有一个子类DefaultConfig，主要负责两件事情：一是实现了RepositoryChangeListener接口，在onRepositoryChange时来更新属性；二是实际负责获取属性（按照优先级去不同地方）</p>
<p>总结来说主要流程如下图：</p>
<p><img alt="apollo-配置通知" src="../images/apollo-%E9%85%8D%E7%BD%AE%E9%80%9A%E7%9F%A5.png" /></p>
<p>其中DefaultConfig收到RepositoryChange消息，计算出来更新的配置，然后fireConfigChange发出ConfigChangeEvent事件，通知各个listener。这里的listener包含添加@ApolloConfigChangeListener注解的；用户自己实现ConfigChangeListener接口的；还有负责处理@Value属性的AutoUpdateConfigChangeListener。</p>
<p><strong>apollo是如何自动更新Spring Placeholder的@value的属性的呢</strong>？</p>
<p>apollo在启动时，注册了一个SpringValueProcessor，它的父类abstract class ApolloProcessor实现了BeanPostProcessor，获取每个bean所有的Filed和Method属性。然后由子类SpringValueProcessor，遍历每个Field上是否有Value注解，获取placeholder里面的key，每个key对应一个SpringValue对象，然后注册到springValueRegistry，也就是说springValueRegistry持有了所有的SpringValue。</p>
<p>然后AutoUpdateConfigChangeListener实现了ConfigChangeListener接口，并持有springValueRegistry，所以在接收到DefaultConfig发布的配置变更后，循环遍历key，找到key对应的SpringValue，然后利用反射更新其值。</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">newVal</span><span class="p">)</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isField</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">injectField</span><span class="p">(</span><span class="n">newVal</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">injectMethod</span><span class="p">(</span><span class="n">newVal</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">injectField</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">newVal</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">IllegalAccessException</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Object</span><span class="w"> </span><span class="n">bean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">beanRef</span><span class="p">.</span><span class="na">get</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bean</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// 通过反射的方式直接更新值。Accessible先设为true，再改回去</span>
<span class="w">    </span><span class="kt">boolean</span><span class="w"> </span><span class="n">accessible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">field</span><span class="p">.</span><span class="na">isAccessible</span><span class="p">();</span>
<span class="w">    </span><span class="n">field</span><span class="p">.</span><span class="na">setAccessible</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>
<span class="w">    </span><span class="n">field</span><span class="p">.</span><span class="na">set</span><span class="p">(</span><span class="n">bean</span><span class="p">,</span><span class="w"> </span><span class="n">newVal</span><span class="p">);</span>
<span class="w">    </span><span class="n">field</span><span class="p">.</span><span class="na">setAccessible</span><span class="p">(</span><span class="n">accessible</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">injectMethod</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">newVal</span><span class="p">)</span>
<span class="w">      </span><span class="kd">throws</span><span class="w"> </span><span class="n">InvocationTargetException</span><span class="p">,</span><span class="w"> </span><span class="n">IllegalAccessException</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Object</span><span class="w"> </span><span class="n">bean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">beanRef</span><span class="p">.</span><span class="na">get</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bean</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">methodParameter</span><span class="p">.</span><span class="na">getMethod</span><span class="p">().</span><span class="na">invoke</span><span class="p">(</span><span class="n">bean</span><span class="p">,</span><span class="w"> </span><span class="n">newVal</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
</code></pre></div>
<blockquote>
<p>但是这种方式有一个问题啊，apollo在初始化时是把配置属性集成到Spring的PropertySource 体系中的，但是上面的方式它是直接更新bean的属性值，并没有去更新PropertySource 体系中的值，也就是这时通过applicationContext.getEnvironment().getProperty(key)拿到的还是旧值（已验证确认）</p>
<p>不过springcloud提供了ContextRefresher.refresh()方法，里面<code>this.context.publishEvent(new EnvironmentChangeEvent(this.context, keys));</code>，spring会去重新加载配置</p>
</blockquote>
<p><strong>Apollo config如何集成到Spring PropertySource 体系中</strong>？</p>
<p>ConfigPropertySource继承了EnumerablePropertySource接口，是连接config和PropertySource接口的桥梁（PropertySource接口就是要求实现其getProperty()获取属性方法即可）。</p>
<p>一个ConfigPropertySource对应一个config，ConfigPropertySourceFactory注册了所有的ConfigPropertySource。在系统初始化时，ApolloApplicationContextInitializer和PropertySourcesProcessor会根据ConfigPropertySourceFactory拿到所有的ConfigPropertySource，然后注册到Spring的PropertySource 里<code>environment.getPropertySources().addFirst(composite)</code>。</p>
<h1 id="apollo_2">从apollo源码可以学习借鉴什么？<a class="headerlink" href="#apollo_2" title="Permanent link">&para;</a></h1>
<p>集成Spring boot，如何读取配置文件，和@EnableApollo，如何动态注册Bean，如何使用BeanPostProcessor，如何动态修改Bean的属性值。</p>
<h2 id="spring">Spring相关<a class="headerlink" href="#spring" title="Permanent link">&para;</a></h2>
<ul>
<li>如何利用注解赋予当前字段值</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="nd">@Override</span>
<span class="kd">protected</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">processField</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">bean</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">Field</span><span class="w"> </span><span class="n">field</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ApolloConfig</span><span class="w"> </span><span class="n">annotation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AnnotationUtils</span><span class="p">.</span><span class="na">getAnnotation</span><span class="p">(</span><span class="n">field</span><span class="p">,</span><span class="w"> </span><span class="n">ApolloConfig</span><span class="p">.</span><span class="na">class</span><span class="p">);</span>
<span class="w">    </span><span class="n">Preconditions</span><span class="p">.</span><span class="na">checkArgument</span><span class="p">(</span><span class="n">Config</span><span class="p">.</span><span class="na">class</span><span class="p">.</span><span class="na">isAssignableFrom</span><span class="p">(</span><span class="n">field</span><span class="p">.</span><span class="na">getType</span><span class="p">()),</span>
<span class="w">                                </span><span class="s">&quot;Invalid type: %s for field: %s, should be Config&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="p">.</span><span class="na">getType</span><span class="p">(),</span><span class="w"> </span><span class="n">field</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 将自定义注解中的值解析，注入对应字段</span>
<span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">namespace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">annotation</span><span class="p">.</span><span class="na">value</span><span class="p">();</span>
<span class="w">    </span><span class="n">Config</span><span class="w"> </span><span class="n">config</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ConfigService</span><span class="p">.</span><span class="na">getConfig</span><span class="p">(</span><span class="n">namespace</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 通过反射工具将值赋予字段</span>
<span class="w">    </span><span class="n">ReflectionUtils</span><span class="p">.</span><span class="na">makeAccessible</span><span class="p">(</span><span class="n">field</span><span class="p">);</span>
<span class="w">    </span><span class="n">ReflectionUtils</span><span class="p">.</span><span class="na">setField</span><span class="p">(</span><span class="n">field</span><span class="p">,</span><span class="w"> </span><span class="n">bean</span><span class="p">,</span><span class="w"> </span><span class="n">config</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>在方法上添加的注解，监听到变更后执行本方法。类似@EventListener</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">// 示例</span>
<span class="nd">@ApolloConfigChangeListener</span>
<span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">onChange1</span><span class="p">(</span><span class="n">ConfigChangeEvent</span><span class="w"> </span><span class="n">changeEvent</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">changeEvent1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">changeEvent</span><span class="p">;</span>
<span class="p">}</span>

<span class="nd">@Override</span>
<span class="kd">protected</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">processMethod</span><span class="p">(</span><span class="kd">final</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="n">bean</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Method</span><span class="w"> </span><span class="n">method</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ConfigChangeListener</span><span class="w"> </span><span class="n">configChangeListener</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConfigChangeListener</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nd">@Override</span>
<span class="w">      </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">onChange</span><span class="p">(</span><span class="n">ConfigChangeEvent</span><span class="w"> </span><span class="n">changeEvent</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 也就是说onChange时会调用method</span>
<span class="w">        </span><span class="n">ReflectionUtils</span><span class="p">.</span><span class="na">invokeMethod</span><span class="p">(</span><span class="n">method</span><span class="p">,</span><span class="w"> </span><span class="n">bean</span><span class="p">,</span><span class="w"> </span><span class="n">changeEvent</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span><span class="w"> </span>
<span class="p">}</span>
</code></pre></div>
<h2 id="_4">设计模式<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h2>
<ul>
<li>观察者模式</li>
</ul>
<p>代码中使用到了大量的观察者模式，用以代码解耦。ReleaseMessageScanner扫描到releaseMessage变更后，发出event。DefaultConfig在判断configChange后，发出event，等等。</p>
<ul>
<li>
<p>模板设计模式
    如config接口，在抽象类AbstractConfig定义一些通用的方法，中间某些关键的具体逻辑交给具体子类DefaultConfig来实现</p>
</li>
<li>
<p>工厂模式</p>
<p><img alt="DefaultConfigFactoryManager" src="../images/DefaultConfigFactoryManager.png" /></p>
</li>
</ul>
<h2 id="_5">编码技巧<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h2>
<ul>
<li>使用java底层的http发出HTTP请求</li>
<li>Spring的DeferredResult,实现将请求挂起，异步返回response。也是长轮询如何实现的例子！</li>
</ul>
<p>部门OSS ak之前一直是明文配置在apollo上，管理不规范，一些开发甚至测试可能不小心造成泄漏。所以需要将其加密管理起来，利用jasypt，将密文ENC(密文)写在apollo里，将秘钥jasypt.encryptor.password在程序初始化时添加到environment的PropertySource中，第一位。这样程序就可以直接获取到明文了。</p>
<h1 id="_6">参考资料<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h1>
<p><a href="https://www.iocoder.cn/categories/Apollo/">Apollo源码解析-芋道源码</a></p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../..", "features": ["search.highlight", "navigation.instant", "navigation.tracking", "navigation.expand", "toc.integrate", "content.code.copy"], "search": "../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>