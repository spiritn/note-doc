
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://spiritn.github.io/note-doc/database/SQL%E4%BC%98%E5%8C%96/">
      
      
      
      
        
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.1">
    
    
      
        <title>SQL优化 - 我的技术文档</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.484c7ddc.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="blue" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#sql_1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="我的技术文档" class="md-header__button md-logo" aria-label="我的技术文档" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            我的技术文档
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              SQL优化
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="blue" data-md-color-accent="indigo"  aria-hidden="true"  type="radio" name="__palette" id="__palette_0">
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



  

<nav class="md-nav md-nav--primary md-nav--integrated" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="我的技术文档" class="md-nav__button md-logo" aria-label="我的技术文档" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    我的技术文档
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_1" >
        
          
          <label class="md-nav__link" for="__nav_1" id="__nav_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    数据库
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1">
            <span class="md-nav__icon md-icon"></span>
            
  
    数据库
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../02-mysql%E6%9E%B6%E6%9E%84/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    mySQL架构
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../01-基础.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    基础
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../03-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    InnoDB存储引擎
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../04-%E7%B4%A2%E5%BC%95/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    索引
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../05-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    日志系统
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Java
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Java
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../java/java8/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    JAVA8
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../java/spring/spring/IocContainer/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    spring
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="sql">SQL优化<a class="headerlink" href="#sql" title="Permanent link">&para;</a></h1>
<p>你都做过哪些SQL优化？调优知道吗？怎么处理慢SQL？等等</p>
<ul>
<li>业务层面</li>
</ul>
<p>比如可以加限制条数和限制时间范围：查老师最近登录的记录，只允许你查最近一个月的，再多就不允许了。</p>
<ul>
<li><strong>SQL层面</strong></li>
</ul>
<p>SQL优化和索引优化</p>
<ul>
<li><strong>数据库架构</strong></li>
</ul>
<p>分库分表：</p>
<p>读写分离：课程报告表数据量很多，做了读写分离。我是想引入shardingJDBC，但是和leader沟通后说时间紧有风险，目前也是只实现读写不同的库，所以自己通过注解实现了一套，每个SQL上走不同的数据库。</p>
<ul>
<li>数据库服务器层面</li>
</ul>
<p>服务器端也可以做些调优，调整buffer poll ，磁盘IO等参数，一般由公司的运维/DBA负责。</p>
<h2 id="sql_1">慢SQL怎么处理？<a class="headerlink" href="#sql_1" title="Permanent link">&para;</a></h2>
<blockquote>
<p>注意要从三个步骤来考虑，先是是否加载多余数据，再考虑是否走索引，最后考虑分表等</p>
</blockquote>
<p>开启慢查询日志，通过skywalking或者数据库的一些监控软件来监控慢SQl，</p>
<ul>
<li>分析SQL是否加载了多余的数据，是否需要改写SQL缩小查询范围；</li>
</ul>
<p>insert时批量插入数据，避免网络IO</p>
<ul>
<li>查看索引的使用情况，分析SQL的查询计划，修改SQl或者增加索引，避免全表扫描。</li>
</ul>
<p>可以建立适当的联合索引和覆盖索引，索引如果不能包含null值就提前声明not null</p>
<ul>
<li>最后如果实在表数据量大，是否要读写分离，分库分表。</li>
</ul>
<h2 id="sql_2">SQL优化案例<a class="headerlink" href="#sql_2" title="Permanent link">&para;</a></h2>
<p><a href="https://mp.weixin.qq.com/s/GpRX1uEqUz4eRAQpEU3-eg">zm优化案例</a></p>
<ul>
<li>
<p>不要轻易分组排序，排序操作极耗资源</p>
</li>
<li>
<p>不要使用 select * 写法，只查询需要的列</p>
</li>
<li>
<p>通过 limit 方式分页会导致后续分页越来越慢，可取前一次分页的最大 ID 作为下一页参数输入，进行分页。</p>
</li>
</ul>
<p>分页去除总页数，只显示上一页下一页。</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 虽然 limit 100 和limit 1000000,100 的解释计划相同，但是执行时间差异非常大。</span>
<span class="c1">-- limit m,n 中的 m 数越大，则查询越慢。limit 100 的执行时间 0.05s；limit 1000000,100 的执行时间 35s</span>
<span class="k">select</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="n">students</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span><span class="n">students</span><span class="p">.</span><span class="n">stu_city</span>
<span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">students</span>
<span class="w"> </span><span class="k">join</span><span class="w"> </span><span class="n">students_seller</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">students_seller</span><span class="p">.</span><span class="n">student_id</span>
<span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">created_at</span><span class="o">&gt;=</span><span class="s1">&#39;2021-01-01&#39;</span>
<span class="w">  </span><span class="k">and</span><span class="w"> </span><span class="n">students_seller</span><span class="p">.</span><span class="k">state</span><span class="o">=</span><span class="mi">0</span>
<span class="w">  </span><span class="k">limit</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>

<span class="c1">-- 例如假设第 10000 页取到的 100 行数据中最大的 students.ID 为 54978976，现在需要取得第 10001 页的 100 行数据</span>
<span class="c1">-- 那么可以添加 students.id&gt;54978976,然后取 100 行数据，此方法取得的即为第 10001 页的数据。</span>
<span class="c1">-- 通过 id 字段的范围限制，比简单的 limit m,n 更加高效，即使是大的数据分页也不会导致效率变低。该方法执行时间稳定为 0.05s</span>
<span class="k">select</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="n">students</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span><span class="n">students</span><span class="p">.</span><span class="n">stu_city</span>
<span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">students</span>
<span class="w"> </span><span class="k">join</span><span class="w"> </span><span class="n">students_seller</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">students_seller</span><span class="p">.</span><span class="n">student_id</span>
<span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">created_at</span><span class="o">&gt;=</span><span class="s1">&#39;2021-01-01&#39;</span>
<span class="w">  </span><span class="k">and</span><span class="w"> </span><span class="n">students_seller</span><span class="p">.</span><span class="k">state</span><span class="o">=</span><span class="mi">0</span><span class="w">  </span>
<span class="w">  </span><span class="k">and</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">id</span><span class="o">&gt;</span><span class="mi">54978976</span><span class="w"> </span><span class="c1">-- 取上一次分页的最大ID</span>
<span class="w">  </span><span class="k">limit</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
</code></pre></div>
<ul>
<li><strong>使用union/union all 替换 where 子句中的 or 连接条件</strong></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">-- 需求：查询18年后和有对应销售人员的学生</span>
<span class="c1">-- 1.因为条件里有 &gt;, &gt;=，所以使用or不走索引，扫描全表。</span>
<span class="k">select</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">students</span>
<span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">created_at</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="s1">&#39;2021-05-01&#39;</span>
<span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">referrer_user_id</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w"> </span><span class="c1">-- 2.改成union，会走索引，而且会走覆盖索引using index，效率很高</span>
<span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">from</span><span class="w"> </span>
<span class="w"> </span><span class="p">(</span><span class="k">select</span><span class="w"> </span><span class="n">id</span>
<span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">students</span>
<span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">created_at</span><span class="o">&gt;=</span><span class="s1">&#39;2021-05-01&#39;</span>
<span class="w"> </span><span class="k">union</span>
<span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="n">id</span>
<span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">students</span>
<span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">referrer_user_id</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
</code></pre></div>
<ul>
<li>使join关联查询替换子查询，in，exists写法</li>
</ul>
<p>在 Mysql 的写法中，非常不建议子查询写法。子查询是一个独立的查询，不能参与到驱动表的数据过滤，而且子查询的结果数据会被放到临时表中存放，然后与驱动表进行关联，效率非常低。</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 说明：payments 表使用单独的子查询，type 为 ALL 需要扫描整个 payments 表记录，将返回的结果存放在临时表，然后与 students 表进行匹配。查询耗时 22s</span>
<span class="k">select</span><span class="w"> </span><span class="k">sum</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">money</span><span class="p">)</span>
<span class="k">from</span><span class="w"> </span><span class="n">students</span>
<span class="k">join</span><span class="w"> </span>
<span class="p">(</span><span class="k">select</span><span class="w"> </span><span class="n">payments</span><span class="p">.</span><span class="n">stu_id</span><span class="p">,</span><span class="n">payments</span><span class="p">.</span><span class="n">money</span>
<span class="k">from</span><span class="w"> </span><span class="n">payments</span>
<span class="k">where</span><span class="w"> </span><span class="n">payments</span><span class="p">.</span><span class="n">is_paid</span><span class="o">=</span><span class="mi">1</span>
<span class="w">  </span><span class="k">and</span><span class="w"> </span><span class="n">payments</span><span class="p">.</span><span class="n">is_canceled</span><span class="o">=</span><span class="mi">0</span>
<span class="w">  </span><span class="k">and</span><span class="w"> </span><span class="n">payments</span><span class="p">.</span><span class="n">money</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">t</span><span class="w"> </span>
<span class="w">  </span><span class="k">on</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">t</span><span class="p">.</span><span class="n">stu_id</span>
<span class="w">    </span><span class="k">where</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">created_at</span><span class="o">&gt;=</span><span class="s1">&#39;2021-05-01&#39;</span>
<span class="w">    </span><span class="k">and</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">created_at</span><span class="o">&lt;</span><span class="w"> </span><span class="s1">&#39;2021-06-01&#39;</span><span class="p">;</span>

<span class="c1">-- 说明：不使用子查询，改为 join 写法后。查询首先根据 students.created_at 走索引扫描，然后根据查询的结果与 payments 表的 stu_id 进行关联。查询耗时 1.85s</span>
<span class="k">select</span><span class="w"> </span><span class="k">sum</span><span class="p">(</span><span class="n">payments</span><span class="p">.</span><span class="n">money</span><span class="p">)</span>
<span class="k">from</span><span class="w"> </span><span class="n">students</span>
<span class="k">join</span><span class="w"> </span><span class="n">payments</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">payments</span><span class="p">.</span><span class="n">stu_id</span>
<span class="k">where</span><span class="w"> </span><span class="n">payments</span><span class="p">.</span><span class="n">is_paid</span><span class="o">=</span><span class="mi">1</span>
<span class="w">  </span><span class="k">and</span><span class="w"> </span><span class="n">payments</span><span class="p">.</span><span class="n">is_canceled</span><span class="o">=</span><span class="mi">0</span>
<span class="w">    </span><span class="k">and</span><span class="w"> </span><span class="n">payments</span><span class="p">.</span><span class="n">money</span><span class="o">&gt;</span><span class="mi">0</span>
<span class="w">    </span><span class="k">and</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">created_at</span><span class="o">&gt;=</span><span class="s1">&#39;2021-05-01&#39;</span>
<span class="w">    </span><span class="k">and</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">created_at</span><span class="o">&lt;</span><span class="w"> </span><span class="s1">&#39;2021-06-01&#39;</span><span class="p">;</span>
</code></pre></div>
<p><strong>join还可以用来替代not in</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 查询是统计 users 表创建时间大于 &#39;2021-05-20 12:00:00&#39;，且不在 users_account_number 表中的用户 ID</span>
<span class="c1">-- 请注意 id=2 的 select_typ 类型为 DEPENDENT SUBQUERY，表示外层 select 结果需要依赖于子查询的结果。效率会非常差</span>
<span class="k">select</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">id</span><span class="w"> </span>
<span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="n">u</span><span class="w"> </span>
<span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">updated_at</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="s1">&#39;2021-05-20 12:00:00&#39;</span>
<span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">in</span><span class="p">(</span><span class="k">select</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">users_account_number</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="w"> </span><span class="c1">-- 直接用 join/left join 的写法替代，效率将会有大幅提升</span>
<span class="k">select</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">id</span><span class="w"> </span>
<span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="n">u</span><span class="w"> </span>
<span class="w"> </span><span class="k">left</span><span class="w"> </span><span class="k">join</span><span class="w"> </span><span class="n">users_account_number</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">a</span><span class="p">.</span><span class="n">user_id</span>
<span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">updated_at</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="s1">&#39;2021-05-20 12:00:00&#39;</span>
<span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">user_id</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">null</span><span class="p">;</span>
</code></pre></div>
<ul>
<li>索引字段类型错误或函数运算导致索引失效</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">-- users 表的 mobile 字段是 varchar 类型，并且创建有索引，但是输入参数是整形，导致查询无法走索引扫描，type 为 ALL 全表扫描</span>
<span class="k">select</span><span class="w"> </span><span class="o">*</span>
<span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">users</span>
<span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">mobile</span><span class="o">=</span><span class="mi">13999999999</span><span class="p">;</span>

<span class="c1">-- mobile 为 varchar 类型，则在参数上添加引号&#39;&#39;标识为字符类型 直接走唯一索引</span>
<span class="k">select</span><span class="w"> </span><span class="o">*</span>
<span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">users</span>
<span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">mobile</span><span class="o">=</span><span class="s1">&#39;13999999999&#39;</span><span class="p">;</span>
</code></pre></div>
<p>created_at字段函数运算导致索引失效</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 由于在 students.created_at 字段上使用 date 函数，导致无法通过 created_at 列匹配满足时间要求的数据，通过 rows 列可以看到是全表扫描 5285w 数据量。</span>
<span class="o">#</span><span class="w"> </span><span class="err">或许有人会疑问既然是全表扫描，为什么</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="err">是</span><span class="w"> </span><span class="k">index</span><span class="w"> </span><span class="err">而不是</span><span class="w"> </span><span class="k">ALL</span><span class="err">。这是因为</span><span class="w"> </span><span class="n">students</span><span class="w"> </span><span class="err">表只用到</span><span class="w"> </span><span class="n">created_at</span><span class="w"> </span><span class="err">和</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="err">列，这两列是直接包含在索引中的，查询是走的覆盖索引。</span>
<span class="k">select</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">students</span>
<span class="w"> </span><span class="k">join</span><span class="w"> </span><span class="n">students_seller</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">students_seller</span><span class="p">.</span><span class="n">student_id</span>
<span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="nb">date</span><span class="p">(</span><span class="n">students</span><span class="p">.</span><span class="n">created_at</span><span class="p">)</span><span class="o">=</span><span class="s1">&#39;2021-05-05&#39;</span>
<span class="w">  </span><span class="k">and</span><span class="w"> </span><span class="n">students_seller</span><span class="p">.</span><span class="k">state</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

<span class="c1">-- 由于是查询注册时间为 2021-05-05 日的学生，那么可以替代为使用 created_at&gt;= ... and &lt;= 的写法</span>
<span class="c1">-- 优化后查询根据 students.created_at 走索引范围查询，匹配行数 rows 为 134092 条，然后与 students_seller 表关联，效率非常高。</span>
<span class="k">select</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">students</span>
<span class="w"> </span><span class="k">join</span><span class="w"> </span><span class="n">students_seller</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">students_seller</span><span class="p">.</span><span class="n">student_id</span>
<span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">created_at</span><span class="o">&gt;=</span><span class="s1">&#39;2021-05-05 00:00:00&#39;</span>
<span class="w">   </span><span class="k">and</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">created_at</span><span class="o">&lt;=</span><span class="s1">&#39;2021-05-05 23:59:59&#39;</span>
<span class="w">  </span><span class="k">and</span><span class="w"> </span><span class="n">students_seller</span><span class="p">.</span><span class="k">state</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</code></pre></div>
<ul>
<li>where + order by + limit 查询陷阱</li>
</ul>
<p>在程序设计中，经常需要用到 where+order by+limit 写法获取满足条件的、排序后的 N 条数据结果。这种写法本身并没有问题，但是在实际使用中，这条语句却常常引起严重的性能问题，需要我们重点关注。</p>
<div class="highlight"><pre><span></span><code><span class="o">#</span><span class="w"> </span><span class="err">查询是想取得学生注册时间在</span><span class="w"> </span><span class="mi">2021</span><span class="o">-</span><span class="mi">04</span><span class="o">-</span><span class="mi">05</span><span class="w"> </span><span class="err">的，并且</span><span class="w"> </span><span class="k">state</span><span class="o">=</span><span class="mi">0</span><span class="w"> </span><span class="err">的，按照更新时间取得最近</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="err">条学生记录。</span>
<span class="o">#</span><span class="w"> </span><span class="err">请注意解释计划中的</span><span class="w"> </span><span class="k">key</span><span class="w"> </span><span class="err">为</span><span class="w"> </span><span class="n">updated_at</span><span class="w"> </span><span class="err">字段，我们明明是对</span><span class="w"> </span><span class="n">created_at</span><span class="w"> </span><span class="err">字段做范围限制，为啥</span><span class="w"> </span><span class="n">MySQL</span><span class="w"> </span><span class="err">选择走</span><span class="w"> </span><span class="n">updated_at</span><span class="w"> </span><span class="err">列索引？</span>
<span class="k">select</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="n">students</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span><span class="n">students_seller</span><span class="p">.</span><span class="n">seller_id</span><span class="p">,</span><span class="n">students</span><span class="p">.</span><span class="n">stu_city</span>
<span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">students</span>
<span class="w"> </span><span class="k">join</span><span class="w"> </span><span class="n">students_seller</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">students_seller</span><span class="p">.</span><span class="n">student_id</span>
<span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">created_at</span><span class="o">&gt;=</span><span class="s1">&#39;2021-04-05&#39;</span>
<span class="w">  </span><span class="k">and</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">created_at</span><span class="o">&lt;=</span><span class="s1">&#39;2021-04-05 23:59:59&#39;</span>
<span class="w">  </span><span class="k">and</span><span class="w"> </span><span class="n">students_seller</span><span class="p">.</span><span class="k">state</span><span class="o">=</span><span class="mi">0</span>
<span class="w"> </span><span class="k">order</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">updated_at</span><span class="w"> </span><span class="k">desc</span><span class="w"> </span>
<span class="w"> </span><span class="k">limit</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
</code></pre></div>
<p>当查询语句中包含 where+order by+limit 时</p>
<p>由于 MySQL 优化器会认为排序 order by 是非常耗时的操作，如果能在一开始就将结果做排序返回，那是最好的。而且 limit 100 会让优化器认为这 100 条记录是很容易满足的，此时优化器会走如下执行计划：</p>
<div class="codehilite"><pre><span></span><code><span class="mf">1.</span><span class="w"> </span><span class="n">由于</span><span class="w"> </span><span class="n">students</span><span class="mf">.</span><span class="n">updated_at</span><span class="w"> </span><span class="n">字段本身就有索引</span><span class="err">（</span><span class="n">已排序</span><span class="err">），</span><span class="n">按照</span><span class="w"> </span><span class="n">updated_at</span><span class="w"> </span><span class="n">字段每次取</span><span class="w"> </span><span class="mf">100</span><span class="w"> </span><span class="n">条结果</span><span class="err">，</span><span class="n">然后走</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">匹配</span><span class="err">，</span><span class="n">将满足的结果返回</span>

<span class="mf">2.</span><span class="w"> </span><span class="n">重复以上操作</span><span class="err">，</span><span class="n">直到有</span><span class="w"> </span><span class="mf">100</span><span class="w"> </span><span class="n">条结果满足要求</span><span class="err">，</span><span class="n">循环结束</span>

<span class="mf">3.</span><span class="w"> </span><span class="n">如果查询按照</span><span class="w"> </span><span class="n">students</span><span class="mf">.</span><span class="n">updated_at</span><span class="w"> </span><span class="n">排序的数据经过</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">条件过滤后能快速满足</span><span class="w"> </span><span class="mf">100</span><span class="w"> </span><span class="n">条结果输出</span><span class="err">，</span><span class="n">那么查询或许会非常快</span>

<span class="mf">4.</span><span class="w"> </span><span class="n">但如果一致没有取到满足</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">条件的</span><span class="w"> </span><span class="mf">100</span><span class="w"> </span><span class="n">条结果</span><span class="err">，</span><span class="n">会一直循环操作直至遍历</span><span class="w"> </span><span class="n">students</span><span class="w"> </span><span class="n">整个表</span><span class="err">！</span><span class="n">那这个代价是非常恐怖的</span>
</code></pre></div>

<p>可以通过构建子查询的方式，强制先导执行</p>
<div class="highlight"><pre><span></span><code><span class="k">select</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="o">*</span>
<span class="w"> </span><span class="k">from</span>
<span class="w"> </span><span class="p">(</span><span class="k">select</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span><span class="w"> </span><span class="n">students_seller</span><span class="p">.</span><span class="n">seller_id</span><span class="p">,</span><span class="n">s</span><span class="w"> </span><span class="n">tudents</span><span class="p">.</span><span class="n">stu_city</span><span class="p">,</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">updated_at</span>
<span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">students</span>
<span class="w"> </span><span class="k">join</span><span class="w"> </span><span class="n">students_seller</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">students_seller</span><span class="p">.</span><span class="n">student_id</span>
<span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">created_at</span><span class="o">&gt;=</span><span class="s1">&#39;2021-04-05&#39;</span>
<span class="w">  </span><span class="k">and</span><span class="w"> </span><span class="n">students</span><span class="p">.</span><span class="n">created_at</span><span class="o">&lt;=</span><span class="s1">&#39;2021-04-05 23:59:59&#39;</span>
<span class="w">  </span><span class="k">and</span><span class="w"> </span><span class="n">students_seller</span><span class="p">.</span><span class="k">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">t</span>
<span class="k">order</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">updated_at</span><span class="w"> </span><span class="k">desc</span><span class="w"> </span>
<span class="k">limit</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
</code></pre></div>
<h1 id="_1">数据库规范<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h1>
<h2 id="_2">建表规范<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<ul>
<li>数据库表字符集统一设置为 utf8mb4 ，排序规则为 utf8mb4_general_ci</li>
</ul>
<p>当字符集或者排序规则不一致时，会导致表无法关联查询；如果进行字符转换，会导致索引失效，而且也会额外消耗数据库性能；统一的字符集和排序规则设置，能减少不必要的字符集问题</p>
<ul>
<li>必须包含 deleted ，create_time ，update_time 数据列（zm业务规范而已）</li>
</ul>
<p>逻辑删除，create_time ，update_time可以交由数据库自动维护；方便进行增量数据同步（BI部门）</p>
<ul>
<li>尽量不要使用blog和text等大字段</li>
</ul>
<p>数据库在存储大字段的数据时，数据列上只存储指向外部存储的指针，查询时需要通过指针找到外部存储，然后再读取大字段的内容，增加了额外的磁盘IO操作，效率低下！</p>
<p>课程报告表有个字段（知识点内容），长度很大，单独拆分出来。</p>
<ul>
<li>字段类型</li>
</ul>
<p>定长字符串尽量使用 char，不要使用 varchar（注意 char 最大定义为 255 ）；</p>
<p>字段尽量设置为非空（ not null ），并设置 default 属性；</p>
<p>字段长度满足业务需求下尽可能短，</p>
<blockquote>
<p>常见字段类型的长度（以下字段长度均为不为空时的字段长度）</p>
<ul>
<li>
<p>tinyint 1 字节；smallint 2 字节；int 4 字节；bigint 8 字节；</p>
</li>
<li>
<p>date 3 字节；datetime 8 字节；timestamp 4 字节；</p>
</li>
</ul>
<p>字符类型括号中定义的数字为字符数，即 varchar(32) 可以存放 32 个数字或者汉字</p>
<p>如果字段为 varchar 变长类型，当定义小于 255 字节时，需要 1 字节存放字段长度；当定义超过 255 字节时，需要 2 字节存放字段长度</p>
<p>字符类型长度跟字符集有关（其中 utf8 占用 3 字节，utf8mb4 占用 4 字节）</p>
<p>varchar(10) 类型（utf8mb4）字节数： 10*4B+1B=41B</p>
<p>varchar(100) 类型（utf8mb4）字节数：100*4B+2B=402B</p>
<p>char(10) 类型（utf8mb4）字节数：10*4B=40B</p>
</blockquote>
<h1 id="_3">数据库常见问题<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h1>
<h2 id="_4">如何平滑的给表添加字段？<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h2>
<p>如果数据量很大，会锁表。影响线上业务</p>
<ul>
<li>在凌晨业务不繁忙的时候添加字段，不影响线上业务。</li>
<li>提前预留字段，可以预留很多个</li>
<li>新建一张表包含新字段的，然后DTS迁移过去，然后查新表。把老表改成别的名字，新表改成正确的表名。</li>
<li>提前设计，使用key/value方法存储到redis里，优雅！</li>
</ul>
<h1 id="_5">问题案例<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h1>
<h2 id="1">1. 大量同时更新表导致连接池不够用<a class="headerlink" href="#1" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="na">GlobalExceptionHandler(Exception)</span><span class="w">  </span><span class="s">error:nested exception is org.apache.ibatis.exceptions.PersistenceException:  ### Error  querying database. Cause:  org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain  JDBC Connection; nested exception is  java.sql.SQLTransientConnectionException: hikari - Connection is not  available, request timed out after 10000ms.  ### The error  may exist in URL  </span>
</code></pre></div>
<p><strong>排查过程</strong>：</p>
<p>线上短时间大量报错，看日志是数据库连接池不够了。</p>
<p>然后去查看公司的慢SQL日志记录，发现有个SQL是慢SQL，而且时间是不断累加的，也就是开始1秒，然后3秒，4秒。</p>
<p>分析这个SQL很简单就是update操作，条件是where device_id ='cccc'。虽然表记录只有2万多行，但是这个条件列没有建立索引，查看执行计划，是ALL全表扫描。当业务同时发生大批量更新，因为没有索引导致了锁全表，很多SQL占用了连接，慢慢的连接池不够用了</p>
<p><strong>解决方法</strong>：</p>
<p>就是条件字段建立索引。</p>
<p><strong>扩展</strong>：</p>
<p>即便有二级索引，当MySQL预估扫描行数超过全表总数约 20% ～ 30% 时，也会直接升级为全表扫描。这种情况一般不考虑，因为实际的查询行数一般不会超过全表的30%。</p>
<p>Each table index is queried, and the best index is used unless the optimizer believes that it is more efficient to use a table scan. At one time, a scan was used based on whether the best index spanned more than 30% of the table, but a fixed percentage no longer determines the choice between using an index or a scan. The optimizer now is more complex and bases its estimate on additional factors such as table size, number of rows, and I/O block size.</p>
<p><a href="https://blog.csdn.net/n88Lpo/article/details/78099094">https://blog.csdn.net/n88Lpo/article/details/78099094</a>写的不错，有实践证明</p>
<h2 id="2">2. 优化器选择了错误的索引<a class="headerlink" href="#2" title="Permanent link">&para;</a></h2>
<p>背景：名片的申请订单表有几十万条数据，建有（shop_id，order_token，status)的索引，也有time的索引。根据这些条件来查询时，mysql优化器非要走shop_id的索引（区分度不高，大概十几个不同的值），但经测试（force index）发现走time索引肯定更快。</p>
<p>做法：因为shop_id索引区分度不高，且命名也不规范，于是删除之。再测试就走了正确的time索引。</p>
<p>原理：</p>
<p>优化器会根据<strong>扫描行数</strong>，还有<strong>是否使用临时表</strong>，<strong>是否排序</strong>，是否要回表等因素综合判断。</p>
<p>优化器并不知道精确的记录条数，只能根据统计信息进行估算，根据的是索引的区分度。一个索引上不同的值越多，区分度就越好。一个索引上不同的值个数，称为基数，基数越大，索引区分度越好。<code>show index from t</code> 可以查看索引的基数。</p>
<p>优化器是采用采样统计的方式来得到索引的基数，如选10个数据页，统计这些页上的平均值，乘以索引的页数，得到这个索引的基数。</p>
<p>很明显，这个统计信息很可能不准，导致优化器估算的扫描行数也会不准，从而导致选择错误的索引。我们可以用analyze table t来重新统计索引信息，</p>
<p>索引选择异常的处理</p>
<ol>
<li>采用force index强行选择一个索引。但是这种方式不够便捷，也不优美</li>
<li>修改SQL。比如子查询，</li>
<li>新建合适的索引，甚至删除错误的索引</li>
</ol>
<h1 id="88">8.8 理解查询执行计划<a class="headerlink" href="#88" title="Permanent link">&para;</a></h1>
<p>根据你的表、列、索引的细节以及你的WHERE子句中的条件，MySQL优化器考虑了许多技术来有效地执行SQL查询中涉及的查找。对一个巨大的表的查询可以在不读取所有行的情况下进行；涉及几个表的连接可以在不比较每个行的组合的情况下进行。优化器为执行最有效的查询而选择的一组操作被称为 "查询执行计划query execution plan"，也被称为EXPLAIN计划。你的目标是识别EXPLAIN计划中表明查询被很好优化的方面，并学习SQL语法和索引技术，以便在看到一些低效操作时改进计划。</p>
<h2 id="881explain">8.8.1使用EXPLAIN优化查询<a class="headerlink" href="#881explain" title="Permanent link">&para;</a></h2>
<p>EXPLAIN语句提供关于MySQL如何执行语句的信息：</p>
<ul>
<li>
<p>EXPLAIN与SELECT、DELETE、INSERT、REPLACE和UPDATE语句一起工作。</p>
</li>
<li>
<p>当EXPLAIN与可解释语句一起使用时，MySQL显示来自优化器的关于语句执行计划的信息。也就是说，MySQL解释它将如何处理该语句，包括关于如何连接表和以何种顺序连接的信息。关于使用EXPLAIN获得执行计划信息的信息，见第8.8.2节 "EXPLAIN输出格式"。</p>
</li>
<li>
<p>当EXPLAIN与FOR CONNECTION connection_id一起使用，而不是与可解释的语句一起使用时，会显示在指定连接中执行的语句的执行计划。参见章节8.8.4, "获取命名连接的执行计划信息"。</p>
</li>
<li>
<p>对于SELECT语句，EXPLAIN产生额外的执行计划信息，可以使用SHOW WARNINGS来显示。参见章节8.8.3, "扩展的EXPLAIN输出格式"。</p>
</li>
<li>
<p>EXPLAIN对于检查涉及分区表的查询非常有用。参见章节22.3.5, "获取关于分区的信息"。</p>
</li>
<li>
<p>FORMAT选项可以用来选择输出格式。TRADITIONAL是以表格格式输出的。如果没有FORMAT选项，这是默认的。JSON格式以JSON格式显示信息。</p>
</li>
</ul>
<p>在EXPLAIN的帮助下，你可以看到你应该在哪里给表添加索引，以便通过使用索引来查找行，使语句执行得更快。你还可以使用EXPLAIN来检查优化器是否以最佳顺序连接表。为了提示优化器使用与表在SELECT语句中的命名顺序相对应的连接顺序，可以用SELECT STRAIGHT_JOIN开始语句，而不是仅仅用SELECT。(参见章节13.2.9, "SELECT语句"。)然而，STRAIGHT_JOIN可能会阻止索引的使用，因为它禁用了半连接的转换。参见章节8.2.2.1, "用半连接转换优化子查询、派生表和视图引用"。</p>
<p>优化器跟踪有时可以提供与EXPLAIN互补的信息。然而，优化器跟踪的格式和内容在不同的版本中会有变化。详情请见MySQL内部。追踪优化器。</p>
<p>如果你有一个问题，即当你认为应该使用索引时却没有使用，那么运行ANALYZE TABLE来更新表的统计数据，如键的cardinality，这可以影响优化器的选择。参见第13.7.2.1节，"ANALYZE TABLE语句"。</p>
<p>注意
EXPLAIN也可以用来获得关于表中列的信息。EXPLAIN tbl_name与DESCRIBE tbl_name和SHOW COLUMNS FROM tbl_name同义。更多信息请参见章节13.8.1, "DESCRIBE语句 "和章节13.7.5.5, "SHOW COLUMNS语句"。</p>
<h2 id="882-explain">8.8.2 EXPLAIN输出格式<a class="headerlink" href="#882-explain" title="Permanent link">&para;</a></h2>
<p>EXPLAIN语句提供关于MySQL如何执行语句的信息。EXPLAIN与SELECT、DELETE、INSERT、REPLACE和UPDATE语句一起工作。</p>
<p>EXPLAIN为SELECT语句中使用的每个表返回一行信息。它在输出中按照MySQL在处理语句时读取它们的顺序列出表。MySQL使用嵌套循环连接方法解决所有连接。这意味着MySQL从第一个表中读取一条记录，然后在第二个表、第三个表中找到匹配的记录，以此类推。当所有的表都被处理后，MySQL输出所选择的列，并在表列表中回溯，直到找到一个有更多匹配行的表。下一条记录将从这个表中读取，然后继续处理下一个表。</p>
<p>EXPLAIN输出包括分区信息。另外，对于SELECT语句，EXPLAIN产生的扩展信息可以在EXPLAIN之后用SHOW WARNINGS来显示（参见章节8.8.3, "扩展的EXPLAIN输出格式"）。</p>
<blockquote>
<p>注意
在较早的MySQL版本中，分区和扩展信息是使用EXPLAIN PARTITIONS和EXPLAIN EXTENDED产生的。为了向后兼容，这些语法仍然被认可，但是分区和扩展输出现在是默认启用的，所以PARTITIONS和EXTENDED关键字是多余的，并且被废弃。使用它们会导致一个警告；预计它们会在未来的MySQL版本中从EXPLAIN语法中删除。</p>
<p>你不能在同一个EXPLAIN语句中同时使用已废弃的PARTITIONS和EXTENDED关键字。此外，这些关键字都不能与FORMAT选项一起使用。</p>
<p>注意
MySQL Workbench有一个可视化解释功能，提供EXPLAIN输出的可视化表示。见教程。使用解释来提高查询性能。</p>
</blockquote>
<h3 id="explain">EXPLAIN 输出列<a class="headerlink" href="#explain" title="Permanent link">&para;</a></h3>
<p>本节描述了由EXPLAIN产生的输出列。后面的章节提供了关于type和Extra列的其他信息。</p>
<p>EXPLAIN的每一条输出行都提供了关于一个表的信息。每一行都包含了表8.1 "EXPLAIN输出列 "中总结的数值，并且在表的后面有更详细的描述。列名显示在表的第一列中；第二列提供了使用FORMAT=JSON时输出中显示的等效属性名称。</p>
<p><strong>Table 8.1 EXPLAIN Output Columns</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">Column</th>
<th style="text-align: left;">JSON Name</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_id"><code>id</code></a></td>
<td style="text-align: left;"><code>select_id</code></td>
<td style="text-align: left;">The <code>SELECT</code> identifier</td>
</tr>
<tr>
<td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_select_type"><code>select_type</code></a></td>
<td style="text-align: left;">None</td>
<td style="text-align: left;">The <code>SELECT</code> type</td>
</tr>
<tr>
<td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_table"><code>table</code></a></td>
<td style="text-align: left;"><code>table_name</code></td>
<td style="text-align: left;">The table for the output row</td>
</tr>
<tr>
<td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_partitions"><code>partitions</code></a></td>
<td style="text-align: left;"><code>partitions</code></td>
<td style="text-align: left;">The matching partitions</td>
</tr>
<tr>
<td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_type"><code>type</code></a></td>
<td style="text-align: left;"><code>access_type</code></td>
<td style="text-align: left;">The join type</td>
</tr>
<tr>
<td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_possible_keys"><code>possible_keys</code></a></td>
<td style="text-align: left;"><code>possible_keys</code></td>
<td style="text-align: left;">The possible indexes to choose</td>
</tr>
<tr>
<td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_key"><code>key</code></a></td>
<td style="text-align: left;"><code>key</code></td>
<td style="text-align: left;">The index actually chosen</td>
</tr>
<tr>
<td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_key_len"><code>key_len</code></a></td>
<td style="text-align: left;"><code>key_length</code></td>
<td style="text-align: left;">The length of the chosen key</td>
</tr>
<tr>
<td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_ref"><code>ref</code></a></td>
<td style="text-align: left;"><code>ref</code></td>
<td style="text-align: left;">The columns compared to the index</td>
</tr>
<tr>
<td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_rows"><code>rows</code></a></td>
<td style="text-align: left;"><code>rows</code></td>
<td style="text-align: left;">扫描行数的预估</td>
</tr>
<tr>
<td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_filtered"><code>filtered</code></a></td>
<td style="text-align: left;"><code>filtered</code></td>
<td style="text-align: left;">Percentage of rows filtered by table condition</td>
</tr>
<tr>
<td style="text-align: left;"><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_extra"><code>Extra</code></a></td>
<td style="text-align: left;">None</td>
<td style="text-align: left;">Additional information</td>
</tr>
</tbody>
</table>
<ul>
<li><code>Extra</code> (JSON name: none)</li>
</ul>
<p>这一列包含关于MySQL如何解决查询的额外信息。查看 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-extra-information"><code>EXPLAIN</code> Extra Information</a>.</p>
<p>没有与<code>Extra</code>列相对应的单一JSON属性；但是，在这一列中可能出现的值被暴露为JSON属性，或作为<code>message</code>属性的文本。</p>
<h2 id="_6">表设计性能原则<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h2>
<ul>
<li>
<p>数据类型：比如能用smallInt就不要用int。能用整数类型的就不要用char类型，因为他们占用的存储空间是不一样的</p>
</li>
<li>
<p>使用非空约束。不仅避免业务上非空的判断，也容易创建索引。甚至节省存储空间。</p>
</li>
<li>
<p>合理增加冗余字段，减少关联查询</p>
</li>
<li>
<p>适当拆分表。把过长的字段和不常用的字段拆分成单独的表</p>
</li>
</ul>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../..", "features": ["search.highlight", "navigation.instant", "navigation.tracking", "navigation.expand", "toc.integrate", "content.code.copy"], "search": "../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>